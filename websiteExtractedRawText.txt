ICS 462, Artificial Intelligence for Games ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Homepage The specs for the AI Shootout Group Presentation and the Final Project AI Shootout report are posted on the Assignments page. Also check the Final Project AI Shootout specs for updates on teams and the new shootout.conf file. The final exam cannot be moved later because at least one student has a final exam for another class right after ours. So see you at 7:30 a.m. at the employee/vendor entrance at the loading dock off Maile Way (between Hamilton Library and Hamilton Library Addition). Added to Laulima's Resources, bzflag_boost.zip, which is equivalent code to today's (10/2) in-class code, except this integrates Boost's A* planner with BZFlag instead of YAGSBPL. Feel free to use whichever one you find easier to understand. Today's (10/2) working code for integrating YAGSBPL into BZFlag is posted in the Resources section of Laulima. The only change from the in-class version was to move the didAstar=true statement to the then part of the if(!didAstar) rather than the else. See the Resources section for how to set up Properties to debug bzflag. Also, look on Laulima's Resources for the Quiz Solutions. I've changed my office hours from Tuesdays & Fridays to Tuesdays 9:30-11:30 & Thursdays 9:30-10:30 effectively immediately. But all of you are welcome to stop by my office anytime I am in, office hours or not. If I'm too busy to talk to you, I'll let you know and reschedule. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Homepage The specs for the AI Shootout Group Presentation and the Final Project AI Shootout report are posted on the Assignments page. Also check the Final Project AI Shootout specs for updates on teams and the new shootout.conf file. The final exam cannot be moved later because at least one student has a final exam for another class right after ours. So see you at 7:30 a.m. at the employee/vendor entrance at the loading dock off Maile Way (between Hamilton Library and Hamilton Library Addition). Added to Laulima's Resources, bzflag_boost.zip, which is equivalent code to today's (10/2) in-class code, except this integrates Boost's A* planner with BZFlag instead of YAGSBPL. Feel free to use whichever one you find easier to understand. Today's (10/2) working code for integrating YAGSBPL into BZFlag is posted in the Resources section of Laulima. The only change from the in-class version was to move the didAstar=true statement to the then part of the if(!didAstar) rather than the else. See the Resources section for how to set up Properties to debug bzflag. Also, look on Laulima's Resources for the Quiz Solutions. I've changed my office hours from Tuesdays & Fridays to Tuesdays 9:30-11:30 & Thursdays 9:30-10:30 effectively immediately. But all of you are welcome to stop by my office anytime I am in, office hours or not. If I'm too busy to talk to you, I'll let you know and reschedule. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Assignments ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Assignments Assignment Policy For questions and answers about the assignments, please check the discussion board on Laulima. Final Project AI Shootout specs writing assignment 1 specs oral assignment 1 specs oral assignment 2 specs oral assignment 3 specs programming assignment 1 specs programming assignment 2 specs programming assignment 3 specs writing assignment 2 specs writing assignment 3 specs David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Programming Assignment 1 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Programming Assignment 1 Due Wed 9/25 before midnight via Laulima Modify BZFlag so that robot tanks on the same team try to find each other and move as a unit ("flocking behavior"), then in Capture the Flag mode, they head toward an enemy flag to try to capture it and then try to return the captured flag to its own home base. Also add code to immediately drop flags that are not opponent team flags. To test this, change the server configuration so that the random world generates with very few (like 0) obstacles and turn off shooting by enemy tanks. Your implementation of flocking must include separation, cohesion and alignment steering behaviors. Hints Start by computing the center of mass of all teammates (not including the current robot tank). To find all other players, look at the for loop in RobotPlayer::doUpdateMotion. Note that players may enter and leave in the middle of a game, so check if World::getWorld()->getPlayer(index) returns NULL before accessing it's getTeam() to find out its team color. Also getPlayer(0) is always NULL, so to get player 0 (the local player running bzflag.exe), you have to use LocalPlayer::getMyTank(). Test this by changing RobotPlayer::doUpdateMotion() to move toward the center of mass instead of following the path to the nearest target (when not evading). Next limit the center of mass (CoM) to only those teammates within a certain neighborhood distance from the robot. Test by using a neigborhood of BZDBCache::worldSize in the above code. Add separation by computing a CoM with a neighborhood of a small number of BZDBCache::tankRadius units. Compute the velocity vectors for each and multiply them by constant weights and sum the vectors. Be sure to check for and handle appropriately the case where the neighborhood has a count of 0 (e.g., all teammates are too far away to exert separation forces). Finally add the velocity vector for matching the team's speed and alignment. Since flocking works best in wide open worlds, you might want to change the server parameters to lower the building density. Here is a sample conf file. Store this in sample.conf in the same directory as bzfs.exe and run "bzfs.exe -conf sample.conf" (or store somewhere else and give the full path to sample.conf). Here is a world with only two bases: empty.bzw. Edit your configuration file to load this world. To capture a flag, start by finding the locations of all the team flags. For example, you can print out team flags and their location with controlPanel's addMessage method. The Flag class is defined in Flag.h and it has data member float position[3] and data member FlagType* type. FlagType has data member TeamColor flagTeam, which is the same type as the robot's TeamColor returned by getTeam(). Flags that are not team flags (e.g., Velocity flags that allow a tank to go faster than normal) will have TeamColor == NoTeam. TeamColor is defined in global.h as an enum. World.h defines the class World and the static method World getWorld(), which returns the current World. World has method bool allowTeamFlags(), which is true only in Capture the Flag mode, so your code should always check this before doing anything related to teams. World also has the method int getMaxFlags(), which returns the maximum number of flags in the world and the method Flag& getFlag(int index) that can be used to get to each flag in the world. This allows you to loop through all flags in the world, check their type's flagTeam to see if it is NoTeam. If not, then you can print the flag's TeamColor (in type->flagTeam) and its location (in position). Next choose a team flag with color different from your team's color and Seek to that team flag's location. As all robot tanks use the same code, they will all choose the same team flag to Seek toward. An optional improvement would be to Seek towards the flag of the opponent team with the best team record whose flag is on the ground rather than Seeking the first flag with a different color or (slightly better that just taking the first flag): Seek the closest flag of a different color (only try the improvements after you get the basic version working first). You can check to see if your robot or a teammate has picked up an opponent team flag by checking FlagSet's data member FlagStatus status. If the FlagStatus (an enum defined in Flag.h) is equal to FlagOnTank (versus FlagOnGround), then you can check the Flag class' data member PlayerId owner to see who is holding the flag. To find a tank from its PlayerId, loop through all tanks just as in assignment 1. Do not use lookupPlayer in Roster.cxx as that method returns the remotePlayer instead of the localPlayer and so its position/velocity are delayed by the round trip to the server (even though dead reckoning is used to try to minimize this, if the robot turns, the turn can't be predicted by dead reckoning, so the remotePlayer data will be slightly off). To head towards a flag, you can Seek it's location and blend that with your flocking code as a fourth behavior with appropriate weight (try out different values to see what works best). To find the location of a base, use World getWorld() to get the World and then inline const float* World::getBase(int _team, int base) const to get the BaseParms. BaseParms[0], BaseParms[1], and BaseParms[2] are the posiiton of the base. The _team parameter is the same as TeamColor and the base parameter is just 0 for the first base (there is only one home base per team currently in the game, even though this code allows for future expansion to multiple home bases per team). To drop a flag, use serverLink->sendDropFlag(const PlayerId& dropper, const float* position) to send this request to the server. Note that you cannot drop certain bad flags, so check that by dropping only when (flag->endurance != FlagSticky). The inline FlagType* Player::getFlag() const method returns FlagType. If the tank is not carrying a flag, getFlag() will return Flags::Null. If there is a flag, check its flagTeam to see if it is NoTeam or if its flagTeam is the same as the tank's getTeam(). The current version of BZFlag does not allow robots to pick up/drop flags. Download my fixes in robotFlags-2.4.2.zip (last revised on 9/10/13) for bzflag and bzfs version 2.4.2, unzip it and replace the corresponding files in your src and include directory with these files. You will have to quit bzfs and rebuild it. Likewise with bzflag. Zip together a README file and only the files that you modified into a1.zip and submit your assignment by uploading the zip file to Laulima. The README ASCII text file should describe how to build your mods and should assume that the reader already knows how to build the regular BZFlag application on the reader's choice of platform. If you would like to print debugging information to the screen, one way to do this is to use the controlPanel's addMessage(const std::string&, const int mode = 3) method. To get to the controlPanel, #include "playing.h" as playing.h declares extern ControlPanel* controlPanel. To use addMessage, try something like this: 

char buffer[128];
sprintf (buffer, "getCurMaxPlayers() is  %d",
    World::getWorld()->getCurMaxPlayers());
controlPanel->addMessage(buffer);

 Note that the above hints assume that you implement flocking in a similar fashion to the code on the book's website (flocking_demo.cpp). You are free to implement this in any fashion that includes the 3 behaviors of separation, cohesion and alignment. For example, excercise 9a at the end of Chapter 3 assumes that separation is implemented as an inverse square law for each teammate instead of moving away from the center of mass of a small nearby neigborhood of teammates (I suspect that this is because sole author Millington wrote the first edition and co-author Funge wrote the excercises added to the 2nd edition without reading the code). An inverse square law is probably more accurate as the robot will move away more strongly from closer teammates. Also it's immune to poor behavior from bad choices of neighborhood size. But it is also very slightly more computationally intensive (more multiplications). Ultimately I doubt whether you will really be able to notice any difference (in either behavior or computation time). My solution modifies only RobotPlayer.h (11 lines added) and RobotPlayer.cxx (199 lines added). Line counts do not include comments, debug printing or blank lines. If your solution starts to require considerably more code, please come see me as you are likely doing too much. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Programming Assignment 2 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Programming Assignment 2 Due Wed 10/9 before midnight Modify BZFlag so that robot tanks use A* search to find a path to a goal location such as an enemy flag or the robot tank's home base. Test your code by running a single robot tank in a world map with a barrier such as barrier.bzw. Here is a simple bzfs configuration file to load barrier.bzw: barrier.conf. You can change the size of the world by editing barrier.bzw with an ASCII text editor. Hints I recommend that you use an A* search package rather than writing your own A* code. Look at the External links section of Wikipedia's A* search algorithm page for a good list of such packages. For my solution, I used YAGSBPL but you are free to choose your own package or even write your own A* code (may actually be easier if you don't know how to use templates in C++). You can also try the Boost library. The astar_search is described here and here is sample code for implicit graphs such as needed for this assignment (this compiles and runs for me on VS 10). If you use YAGSBPL, I recommend the previous v2.0 instead of the current v2.1 as I got an error in the current version with the new binary heap implementation. Also, to avoid VS errors, add return values to the following functions in yagsbpl_base.h as shown: 
	virtual int getHashBin(NodeType& n) { func_redefined = false; return 0;};
	virtual bool isAccessible(NodeType& n) { func_redefined = false; return false;};
	virtual bool storePath(NodeType& n) { func_redefined = false; return false;};
	virtual bool stopSearch(NodeType& n) { func_redefined = false; return false;};
	virtual CostType getHeuristics(NodeType& n1, NodeType& n2) { func_redefined = false; return NULL;};
 Also in planners\A_star.cpp, comment out the printf and exit statements and replace them with a controlPanel addMessage call: 
//printf("ERROR (A_star): At least one of the seed nodes is not accessible!" );
//exit(1);
controlPanel->addMessage("ERROR (A_star): At least one of the seed nodes is not accessible!");
 Update on Wed 9/25/13: YAGSPBL v2.1 works fine on a Mac with XCode 5. For Windows VS 10, it will run if you change line 104 (the pop function) in yagsbpl_base.cpp to read: 
if(heap_size > 0) update(heapArray[0], DOWNONLY_BUBDIR);
 I also modified yagsbpl_base.h to comment out the lines: 
#define _yagsbpl_display_version { if (!YAGSBPL_vDisplay_done) { printf("\n*** You are using YAGSBPL v 2.1. ***\n"); YAGSBPL_vDisplay_done = true; } }
bool YAGSBPL_vDisplay_done = false;
 And I modified yagsbpl_base.cpp to comment out the line: 
_yagsbpl_display_version;
 To add the YAGSPBL code to your VS project, add the path to your yagsbpl folder to your bzflag Properties: Configuration Properties: C/C++: General: Additional Include Directories. Another problem you will have to solve is how to represent the BZFlag world so that you can use A* search to find paths. The built-in representation of BZRegion is computed by splitting the world into convex polygons that do not contain any obstacles. Unfortunately the splitting code has some bugs that show up when obstacles overlap. You are welcome to try to fix this and use the BZRegions as nodes for A* search. Alternatives include tile graphs (easiest) and points of visibility (potentially most efficient during actual search but requires time to set up the graph at game startup). For the tiling approach, just map the location into a node by rounding to the nearest integer. Unfortunately this gives a lot of tiles. For example, the default 400x400 world size gives 800x800 (the 400 specifies -400 to +400) or 640,000 nodes for searching. The current world size can be found in the variable BZDBCache::worldSize (#include "BZDCache.h"). Doing an A* search on 640,000 nodes will most likely slow down your game considerably whenever A* search is carried out. You can scale this by dividing the location coordinates by some constant to reduce the number of tiles by the square of the scaling factor. I used BZDBCache::tankRadius (currently 4.32 world units) to reduce the 640,000 tiles for a 400x400 default world to just 34,294 tiles and that worked well for me. Remember to multiply by the same scaling factor whenever you convert the A* node's integer coordinates back into BZFlag float positions. Another problem you will have to solve is figuring out which A* nodes are connected to which other A* nodes in the A* graph. Fortunately BZFlag has the built-in function const Obstacle* World::getWorld()->inBuilding( const float* pos, float radius, float tankHeight) const; that you can use to check if some position, pos, is inside of a building. I used BZDBCache::tankRadius/2 for the radius to avoid having nodes centered too close to a building. You will find that some positions very close to buildings will map to nodes inside the building. You can check for this and try to map the position to a neighboring node instead of mapping the position to a node that is actually inside the building and causing your A* search to fail as the interior node cannot be reached. If you are using visibility graphs, you can use something like const Obstacle* ShotStrategy::getFirstBuilding(const Ray& ray, float min, float& t); to see if there is an obstacle between one node and another (create a Ray with origin at the first node and direction toward the second node). For the cost function in A* search, use the Euclidean distance (computed by the hypotf function in BZFlag). You will change this later to take into account other stratgic concerns, but for this assignment, just use Euclidean distance between two adjacent nodes as the cost of traversing the two nodes. The Euclidean distance can also be used as the A* search heuristic underestimate of the cost between any two non-adjacent nodes. Do not wait until the last minute to start this assignment as this is undoubtedly the most difficult assignment of the semester. Consider that if pathfinding were easy, then there would not be nearly as many examples of bad pathfinding in commercial games as you currently see. Submitting Zip together a README file and only the files that you modified into a2.zip and submit your assignment by uploading the zip file to Laulima. The README ASCII text file should describe how to build your mods and should assume that the reader already knows how to build the regular BZFlag application on the reader's choice of platform. If you use an A* search package, your README file should describe how to integrate that package into BZFlag. My solution modifies RobotPlayer.h (3 lines added), RobotPlayer.cxx (25 lines added) and adds one more .h file (43 lines) and another .cxx file (70 lines) for a total of 141 additional lines of code. Line counts do not include comments, debug printing or blank lines. They also do not count the YAGSBPL code files that are #included. If your solution starts to require considerably more code, please come see me as you are likely doing too much. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Programming Assignment 3 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Programming Assignment 3 Due Wed 10/23 before midnight Implement three decision trees for robot tanks to decide what to do. Your decision trees must implement the current functionality of BZFlag assignment 3 solution (no improvements please; wait until the next assignment to add your favorite improvements). You should have a decision tree for doUpdateMotion(), for the shooting part of doUpdate() and for the drop flag part of doUpdate(). If you really prefer finite state machines, you can use them instead of decision trees. In particular, doUpdateMotion()'s decision tree looks like: Q0: bot alive? yes: Q1. no: do nothing. Q1: is there is a non-invisible, non-isExpired() shot about to hit bot? yes: evade. no: follow A* search path. The shooting decision tree of doUpdate() looks like: Q0: bot alive? yes: Q1. no: do nothing. Q1: is firing status == Ready? yes: Q2. no: do nothing. Q2: has shot timer elapsed? yes: Q3. no: do nothing. Q3: will shot miss target by less than half a tanklength? yes: Q4. no: do nothing. Q4: are there any buildings in the way? yes: do nothing. no: Q5. Q5: are there any teammates in the way? yes: set shot timer to 0.1f. no: fireShot() and reset shot timer. The drop flags decision tree of doUpdate() looks like: Q0: bot alive? yes: Q1. no: do nothing. Q1: is bot holding a flag? yes: Q2. no: do nothing. Q2: is the flag sticky? yes: do nothing. no: Q3. Q3: is the flag a team flag? yes: Q4. no: drop flag. Q4: is the flag's team == my team? yes: drop flag (note that this can be the same ActionPtr as the yes part of Q5). no: do nothing. Hints I recommend you use the decision tree implementation from the textbook website. I have modified the textbook solution to use method pointers. You can download the files from BZFlagDecisionTree.zip. Note that all of the method pointers expect a RobotPlayer::method and take a single float argument, dt = the delta time since the last frame. Submitting Zip together a README file and only the files that you modified into a3.zip and submit your assignment by uploading the zip file to Laulima. The README ASCII text file should describe how to build your mods and should assume that the reader already knows how to build the regular BZFlag application on the reader's choice of platform. If you used Millington's decision tree code, be sure to describe how to download his code and how to integrate it into BZFlag. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Oral Assignment 1 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Oral Assignment 1 PowerPoint slides due before midnight Wed 9/11 by upload on Laulima's Drop Box Presentation on Wed 9/18 Give a 5 minute presentation arguing why your choice of game feature for BZFlag is the best one to implement next. During the presentation, you will be graded by your fellow students and myself using the UHM General Education Oral Communication Focus Persuasive Oral Presentation Evaluation Form. Please give 6 points for Content and 4 points for Delivery for a total of 10 points. I will drop the highest and lowest scores and average the rest to compute your grade. Also after all presentations, everyone will vote for the top 3 proposed features. The top vote getter will get 30% extra credit, second will get 20% extra credit and third 10%. I will bring paper scoring sheets, so please bring a pen/pencil to record your grades and votes. Assume that your audience are fellow game developers in the same game studio who are also working on BZFlag. So you don't have to explain the game to your audience. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Oral Assignment 2 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Oral Assignment 2 PowerPoint slides due before midnight Sunday 10/13 by upload on Laulima's Drop Box Presentation on Wed 10/16 Give a 2 minute presentation on a piece of code that you wrote for this class with 3 minutes for interaction with your audience (classmates and instructor). For the presentation and especially the interaction, you will be graded by your fellow students and myself using the UHM General Education Oral Communication Focus Informative Oral Presentation Evaluation Form. Please give 3 points for Content and 7 points for Delivery for a total of 10 points. I will drop the highest and lowest scores and average the rest to compute your grade. I will bring paper scoring sheets, so please bring a pen/pencil to record your grades and votes. Assume that your audience are exactly who they are. So you don't have to explain the game or assignment problem to your audience. But you should explain what the code does in the assignment. I recommend that you pick your worst code so that you will get plenty of interaction. The last thing you want is to stand around with no audience interaction. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Oral Assignment 3 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Oral Assignment 3 PowerPoint slides due before midnight Wednesday 11/27 by upload on Laulima's Drop Box Presentation on Monday 12/2 Give a 12 minute presentation with 3 minutes for questions/answers about what your group implemented for the AI Shootout and how you did it. Each member of your group must present for an equal amount of time. Everyone/anyone can answer questions. For the presentation and the questions/answers, you will be graded by your fellow students and myself using the UHM General Education Oral Communication Focus Informative Oral Presentation Evaluation Form. Since this is a group presentation, only the entire group will be graded, so everyone in your group will get the same grade. So get together to practice your presentations! I will drop the highest and lowest scores and average the rest to compute your grade. I will bring paper scoring sheets, so please bring a pen/pencil to record your grades. Assume that your audience are exactly who they are. So you don't have to explain the game or problem to your audience. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Assignment Policy ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Assignment Policy Assignments will be posted on this website and are due at midnight. Each student starts with with seven (7) grace days (any 24 hour period) of lateness for the entire semester. If you use up all of your grace days, then you cannot turn in anything else late. Exceptions to this will only be made for medical reasons (with a doctor's note) or other serious reasons (e.g. a death in the family -- your own death is not a good reason :-). Also, at no time will late assignments be accepted after a solution set to that assignment has been posted. Format Be sure to properly indent and comment your program. Each function, procedure or method should be less than a half page in length. Use mnemonic variable and function/method names. Plagiarism You are expected to do all of your assignments yourself. You are free to use any machine that you wish for your assignments. Unless specified otherwise, under no conditions should people share code. It is alright for people to discuss implementation strategies, problems, bugs, and algorithms (in fact this is encouraged), but each person should write his/her own programs and assignments independently. Any sharing of code is plagiarism (see Impermissible Behaviour) and the students involved will be disciplied by reporting them first to the ICS Department and if this is not the first report for the student, then to the Dean of Students (a while ago, the headline story in Ka Leo was the expulsion of some students for cheating). Late Policy Each student starts with with seven (7) grace days (any 24 hour period) of lateness for the entire semester. If you use up all of your grace days, then you cannot turn in anything else late. Exceptions to this will only be made for medical reasons (with a doctor's note) or other serious reasons (e.g. a death in the family -- your own death is not a good reason :-). Also, at no time will late assignments be accepted after a solution set to that assignment has been handed out. If solutions are to be handed out, this will be posted on the web page and announced in class when the assignment is handed out. For example, student Jane Doe may decide to turn in assignment #1 three days late, in which case she only has four grace days left. If she then turns in assignment #2 five days late, she will get a zero for assignment #2 because she does not have enough grace days left (only 4). However, she can still turn in assignment #3 four days late and get full credit for assignment #3. At this point Jane Doe has used up all of her grace days, so she must turn in all of her remaining assignments on time or get zeros. Saturdays and Sundays count as a normal days. For example, if an assignment is due on Thursday, and you turn it in the following Monday, then you have used up 4 grace days. You use up a whole grace day even if you turn in an assignment only 1 minute after the deadline (more than 24 hours late uses up 2 grace days, etc.). If you turn in assignment #1 one minute late and assignment #2 one minute late, then you have used up 2 late days and only have 5 left. I believe that this is a very flexible late policy. This way, if you are bogged down with work in your other classes during one week, you can postpone work on this class for up to a week. I would suggest that you save your late days for such cases. Furthermore, to encourage people to start assignments early, you will be rewarded by an extra 5% of your grade per day (24 hours) that you turn in your assignment early up to a maximum of 25% (5 days early). Note that if you turn an empty assignment 4 days early, then 0 + 20% of 0 is still 0. On the other hand, it may be to your advantage to turn in an assignment early rather than spend a few more days fine tuning it. If you turn in an assignment twice, I will count only the last version. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Final Project Specs ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Final Project Specs Teams This is a group project with teams of 2-3 students. If you would like to form your own team, please email me the names of the students on your team. If you would like me to help you find a team, please let me know by email. Each team will run its own copy of bzflag on its own laptop computer, connecting to my laptop computer, which will be running bzfs and a bzflag with only an observer (for projection). Each laptop will connect via ethernet cable to a switch that I will provide. Please bring your setup on 12/2 to test connections in preparation for the Shootout on 12/4. Teams are (1) Red: Nick Davis, Ethan Smith, and Andrew Ito, (2) Green: Chih Chin Chang, Troy Kobayashi-Bautista, and John Sult, (3) Blue: Takanori Shiotsu and Tyler Pascua, (4) Purple: Evan Komiya and Christopher Rodrigues. To set up your bzflag program to run with robots of only your own color, comment out -autoTeam in the shootout.conf file, then edit playing.cxx line 4515, in function static void addRobots() that reads: robots[j]->setTeam(AutomaticTeam); and replace AutomaticTeam with your team's color (see above). For example, Nick Davis et al. would change AutomaticTeam to RedTeam. To test your program with fewer than 4 teams (with no home bases/team flags for the missing teams), edit shootout.conf and change the line -mp 0,5,5,5,5,5 to zero out the colors that you don't want. BZFlag World Bzfs will be run with a random capture the flag world (-cr) with size 800 (-worldsize 800), which means a 1600x1600 playing field and randomly rotated world objects (-b) at density 5 (-d 5). See shootout.conf for details on the bzfs configuration. There will be one of each good flag (+f good) and no bad flags (-f bad). Each game will be 15 minutes long (-time 900). Each team will have 5 robot tanks (-mp 0,5,5,5,5,5) with up to 5 observers (4 teams plus me). Jumping will be allowed (-j), but box buildings will have height 20 (-set _boxHeight 20), so your tanks will not be able to grab your own team flag and jump on top of a building to hide out (max jump height is 18.42 with 17 more common). But jumping is still good for emergency shot avoidance. There will not be any teleporters. There is a maximum of 1 shot before reloading (-ms 1), so make your shots count. Tanks will not respawn on buidlings. Additional Constraints Robot tanks are allowed to know where all flags are and what each flag is. Robot tanks are also allowed to know where all other robot tanks are including cloaked/stealthed tanks (so the cloak and stealth flags basically become useless flags). Suggested AI techniques In no particular order, here are some suggestions for AI improvements that could make the difference between winning and losing. Your mileage may vary depending on what the other teams decide to do. Currently robot tanks only shoot if they will miss by less than 1/2 tank length, but will not rotate to shoot even if the enemy tank is nearby. So sometimes you will see tanks roll right past each other on parallel tracks without bothering to turn slightly to take a shot. Change the decision making so that your tanks will prioritize moving into position for a shot if the enemy tank is nearby. Perhaps make an exception if the tank is holding an enemy team flag. Take advantage of the jump capability to avoid incoming shots. Have some of your tanks guard your own team flag. These can camp out in between the two pyramids at the corners of the base as the pyramids provide some cover from in-coming shots, but still allow the tank to shoot at approaching enemy tanks. Take advantage of the non-team flags (after all, this is why BZFlag has Flag in its name). Have your tanks move in formation with the tank holding the enemy team flag in the center to shield it from enemy shots. Improve decision making on which enemy team flag to pursue. This could be as simple as choosing the closest flag or you could look at how many enemy tanks are nearby too. Bring your own team flag with you on your hunt for enemy team flags. This can confuse teams that expect team flags to stay put. On the other hand it can be more dangerous because you are taking your team flag closer to the enemy base. Improve the decision making when a robot tank respawns. Improve pathfinding by taking into account whether enemy tanks can shoot at you along the path. Improve pathfinding by checking on when you should recompute A* search (e.g., when the enemy flag has moved by more than a certain distance). Improve efficiency by having your tanks in the formation share a common A* path. Smooth out your paths by using the path smoothing algorithm in the textbook. Come up with your own idea! David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Writing Assignment 1 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Writing Assignment 1 Due Mon 9/9 at start of class Write 5-6 pages, double-spaced, singled-sided, 10-12 point proportional (i.e., not fixed-width) font with 1-inch margins except 1.5 inch on the right side, with page numbers on the bottom margin critiquing the AI of one or more video games. Start by describing the game and be sure to give both the developer(s) and publisher(s) (look it up in Wikipedia) and platform(s). Then describe the situation in which the AI example(s) occurs and why you consider the AI good or bad. Be sure to include at least one example of AI that impressed you and at least one example of AI that you thought atrocious (may be in different games). Finally for the bad AI example(s) describe how you might fix it. Assume that your audience is your fellow student. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Writing Assignment 1 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Writing Assignment 2 Due Wed 10/30 at start of class Write 5-6 pages, double-spaced, singled-sided,10-12 point proportional (i.e., not fixed-width) font with 1-inch margins except 1.5 inch on the right side, with page numbers on the bottom margin comparing and contrasting 2 or more AI techniques for a particular game purpose. Start by describing the game purpose, then describes each technique (be sure to have at least 2 citations for each technique, one of which can be your textbook). How does it work? Is it labor intensive? Is it hard to code? Are there tools available to help the user? Then compare and contrast the techniques. Is one easier to use? Is there more support for one technique? Does one use up more CPU time? More memory? More disk space? Is one technique better for particular situations than others? Describe the situations and circumstaces that make one technique preferable to the other(s). Assume that your audience is an experienced game programmer who does not know the AI techniques that you are descrbing. He/she is reading your article to decide which AI technique to employ in his/her game. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Writing Assignment 3 ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Writing Assignment 3 Due Wed 12/4 at start of class Write 5-6 pages, double-spaced, singled-sided, 10-12 point proportional (i.e., not fixed-width) font with 1-inch margins except 1.5 inch on the right side, with page numbers on the bottom margin describing what you yourself (not your teammates) did on for the final project AI Shootout. Note that each person on a team must write a separate unique report with no sharing of writing, so each person will get a separate grade. You are welcome to describe the overall AI strategy for your team, but emphasize what you yourself implemented or helped implement. Do not count embedded code fragments toward the page count requirement. Assume that your audience is an experienced game programmer who has heard about BZFlag and is interested in expanding the AI for the robot tanks in the game. So you should start by describing BZFlag and capture-the-flag and the current status of robot tanks in BZFlag. Be sure to end with a summary paragraph that summarizes your AI changes and why you thought they are a good idea. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Course Information ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Course Information Instructor information Professor Name: David N. Chin Email: chin@hawaii.edu Office: POST 317 Office Hours: Tuesdays 9:30-11:30 and Thursdays 9:30-10:30 and by appointment Office Phone: 956-3500 Topic Artificial Intelligence is essential to the suspension of belief in a good video game. For example, the GameSpot review of Crysis 2 said, "Poor AI detracts from the excitement" and the IGN review of Vampire: The Masquerade said, "Unfortunately, the AI has the intelligence of a doorknob sometimes, which keeps the shine off an otherwise delightful and multilayered experience." This course will introduce students to the specific techniques used to simulate artificial intelligence in computer and video games. From the catalog: Techniques to stimulate intelligence in video games: movement, pathfinding with A* search, decision/ behavior trees, state machines, machine learning, tactics. Extend games with your own AI implementa- tions; experience "shootout" contests for the best AI algorithm/implementation. Prerequisites 212 and (314 or 361) and (PHYS 151 or PHYS 170). Student Learning Objectives be able to extend an existing game program by adding AI code be able to program goal-oriented movement of non-player characters be able to write code to find near-optimal paths using A* search and other techniques be able to write decision making code utilizing decision trees, state machines, fuzzy logic, production systems, and/or scripts understand and apply machine learning algorithms to games experience AI program competitions Students can apply knowledge of computing and mathematics appropriate to the discipline Students can analyze a problem and identify and define the computing requirements appropriate to its solution Students can design, implement, and evaluate a computer-based system, precess, component, or program to meet desired needs Students can function effectively on teams to accomplish a common goal Students can communicate effectively with a range of audiences Students can use current techniques, skills, and tools necessary for computing practice Textbooks required: Artificial Intelligence for Games, Second Edition, by Ian Millington and John Funge, publisher: Morgan Kaufmann, ISBN: 9780123747310. required: Presenting to Win, The Art of Telling Your Story, Updated and Expanded Edition (earlier editions are fine too), by Jerry Weissman, publisher: FT Press (Pearson Education), ISBN: 9780137144174. Grading Policy The course grade will be based 15% on assignments, 5% on quizzes, 10% on the Midterm exam, 20% on the Final exam, 40% on oral presentations (see the Oral-Focus section below for breakdown) and 10% on the final game AI Shootout. There will be 6 assignments, 3 short programming assignments and 3 writing assignments (see the Writing-Intensive section below for details). The 3 programming assignments will build toward the Shootout. ICS 462 is writing intensive, so the 3 writing assignments will each be 5-6 pages each with revisions required based on my feedback. The midterm and final will also require some short essay responses. Students must adequately complete all writing assignments to pass the course with a D grade or better. Students who do not complete all writing assignments will get a D- or an F and will not earn W Focus credit. Completing writing assignments satisfactorily includes satisfying the minimum page requirements and submitting revisions following feedback. The grading will be on an absolute scale; if you get 60% or better, then you will get at least a C (unless you do not complete all of your writing assignments satisfactorily, in which case you will get an F regardless of your point average). Above passing, the following scale will be used. This scale may be adjusted so that thresholds are lowered, but I will never raise the thresholds (not even if it means the whole class will get As, which would make me very happy as it would mean that every student has mastered the material). As=85-100%, Bs=70-85%, Cs=55-70% (60% for C), Ds=45-55%. Quizzes The take-home quizzes will be graded as pass (100% credit) or fail (0 credit) with a pass given if you show a reasonable effort toward the solution (so you do not have to get the correct solution for a pass). Quizzes can be turned in either electronically by uploading them to Laulima before the start of class or on paper at the very start of class. Quiz questions will reappear in the Midterm and Final exams with very slight modifications (e.g. changing the numbers of the question parameters), so it will be wothwhile spending the time to work out the quiz problems. Exams The Midterm exam will cover all material prior to the Midterm date and the Final exam will be comprehensive. Only modified quiz questions will appear on the Midterm and Final exams, so everyone should ace the exams! Final AI Shootout ICS 462 will include a final game AI Shootout. Small (3-5 students) teams will implement AI for the open source BZFlag Multiplayer 3D Tank Game and all teams will compete in a Shootout. Every team that has a running implementation will get at least 5 points (0 points for non-running implementations). The top team will get 15 points, which is 5 points extra credit. The remaining teams will be linearly scaled down from 15 to 5 points based on their BZFlag score in the Shootout game. Oral-Focus This is an Oral-focus class, so students will give short presentations to the class worth 40% of your total grade. There will be 4 presentations: 2 individual and 2 small group. The first presentation (5% grade) will be to persuade your classmates, who will play the part of fellow developers in a Game Studio, to select your choice of a game feature to implement in the game that is being implemented by the Game Studio. The second presentation (5% grade) will be a code review of one of your programming assignments. The third presentation (20%) will be with your group presenting the AI techniques that you used for your Shootout. The fourth presentation (10%) will be a post-mortem analysis of what worked and what didn't work in the Shootout. Writing-Intensive This is a Writing-Intensive class, so students will write at least 16 pages (4,000 words) and revise all writing following my feedback. Each writing assignment will be 5-6 pages. The first writing assignment will be to critique a game of your choice on its AI. The second writing assignment will be to compare and contrast two or more different AI techniques for a particular game purpose. The third writing assignment will be a report on what you did for your AI implementation for the final game AI Shootout. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Resources ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Resources General Game AI Reviews of game AI AI Game Programmers Guild AIGameDev.com IEEE article on Making the Jump Into Games textbook website Bzflag Microsoft Visual Studio 2010 Express is the IDE for Bzflag on Windows. For installing bzflag on Windows, dowload the source code, version 2.4.2 from bzflag's Downloads page and follow the Win95/NT instructions in the README.WINDOWS file. The VS project file is in MSVC\build\bzflag.vcxproj (double click it to start Visual Studio). The README.WINDOWS file tells you to install the DirectX SDK (easy package install) and curses. For curses, you can either build it from source code (in src\other\PDCurses with the VS project file in the same directory as the bzflag project file) or download pdcurses and in Visual Studio, select bzflag in the left panel, then under the Project menu, select Properties. In the popup baflag Properties Pages, select Configuration Properties: VC++ Directories and add your unzipped pdc25_vc_w32 directory to both Include Directories and Library Directories. Also, after building bzflag in VS, but before running/debugging the application, copy curses.dll from pdc25_vc_w32 into bzflag-2.4.2\bin_Win32 where libcurl.dll should be already. Also, change the bzflag Properties: Configuration Properties: Debugging: Command to be the full path to bin_Win32\bzflag.exe or better yet ..\..\bin_Win32\bzflag.exe and the Working Directory to be ..\..\bin_Win32 (or the full path) as specified in the README.WINDOWS file. If running/debugging bzflag causes lots of flickering/tearing in the video, try updating your video card driver (bzflag suggestion) or changing your video card 3D settings to override the application settings and always use 2x (or higher) oversampling (worked for me on my NVIDIA card). To debug bzflag in Visual Studio 2010, also change the bzflag Properties: Configuration Properties: C/C++: Output Files: Program Database File Name to be the full path to your bin_Win32 folder or to $(LocalDebuggerWorkingDirectory). If you are running a server on the same machine as your client and you cannot connect to your sever via the "Find Server" menu in bzflag with a alphabetic host name like "localhost" (seems to happen on the UH wireless network), try typing in the numeric IPv4 address for the server (on Windows, you can look up your IP address by running cmd.exe and typing "ipconfig", then look for the IPv4 Address, which should be something like 168.105.83.87). The numeric address 127.0.0.1 is equivalent to "localhost" and this may work for you, so you can avoid calling ipconfig to get the actual IP address. To run bzflag with robots, add "-solo N" without the double-quotes where N is the number of robot tanks to the command line or to Configuration Properties: Debugging: Command Arguments for debugging bzflag. If when compiling bzflag, you get a link error involving regfree, regex, regcomp, regerror, regexec, etc., try adding regex.lib to bzflag's Properties: Configuration Properties: Linker: Input: Additional Dependencies. Also add $(MSBuildProjectDirectory)\regex_Win32_Debug to bzflag's Properties: Configuration Properties: VC++ Directories: Library Directories. You can also use the full path, but if you ever move or copy the bzflag-2.4.2 directory, you will have to remember to change these values. Ethan pointed out on the Laulima Discussion List that if you have a multiprocessor CPU, you can set bzflag's Properties: Configuration Properties: C/C++: General: Multi-processor Compilation to Yes (?MP) for faster compilation. To run bzfs, run "bzfs -conf configuration_file_name.conf" in a cmd.exe window. You can also run it from within VS10, but be sure to change the Debugging Configuration Properties for Command, Working Directory and Command Arguments just like you did for bzflag. Writing Intensive Proofreader's Glossary by McGraw Hill. Get it Write Online explains very well the difference between Which or That? GrammarBook.com lists rules for when to use Commas David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Game AI Reviews ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Game AI Reviews GameSpot's review of Crysis 3 said, "It doesn't help matters that Crysis 3's soldiers and aliens are not the intelligent type. While they're not the dunderheads they could be in Crysis 2, enemies take no notice of arrows that land right next to them, run into obstacles and just keep trying to run, and sometimes ignore you even when you're in plain sight." GameSpot's review of Crysis 2 said, "Poor AI detracts from the excitement" IGN's review of Vampire: The Masquerade said, "Unfortunately, the AI has the intelligence of a doorknob sometimes, which keeps the shine off an otherwise delightful and multilayered experience." Interview with Cevat Yerli, President of Crytek, who talks about 2 deep AI bugs in the shipped Crysis 2 that caused "a bit of a mess". user review of Numen: Contest of Heroes on GameSpot talks about how broken AI significantly reduces the difficulty of gameplay as enemies can be exploited for bad pathfinding. Also describes how the author clicked on an opponent and 5 minutes later, the pathfinding AI was still chasing the opponent in circles. The Science of Mega Man includes an interview with me about the future of AI in games. The Real Science of Mass Effect, a copy on the Bioware forums of an article that originally appeared in the now defunct GamePro magazine that includes an interview with me about AI motives. David N. Chin / Chin@Hawaii.EduICS 462, Artificial Intelligence for Games: Schedule ICS 462, Artificial Intelligence for Games Home Course Info Schedule Resources Assignments Tentative Schedule Monday Wednesday 8/26 Introduction: AI vs. Game AI, read Millington & Funge, Chapters 1-2 Components of a Computer/Video Game, read Jeff Howland's Game Design: The Essence of Computer Games 8/28 Introduction to BZFlag, the target game for this class 9/2 Holiday: Labor Day 9/4 Presenting to Win, read Weissman, entire book 9/9 Movement, Basic 2D & Physics read Millington & Funge, Chapter 3.1-3.5 Writing Assignment 1 draft due 9/11 Movement in BZFlag upload your Powerpoint slides to Laulima 9/16 Jumping, Coordinated Movement, Motor Control & 3D read Millington & Funge, Chapter 3.6-3.9 9/18 Individual Presentation: My Game Feature Proposal 9/23 Pathfinding, Basic read Millington & Funge, Chapter 4.1-4.5 Writing Assignment 1 revision due 9/25 Pathfinding in BZFlag Programming Assignment 1 due 9/30 Pathfinding, Advanced read Millington & Funge, Chapter 4.6-4.9 10/2 more on Pathfinding in BZFlag 10/7 Decision Trees, State Machines & Behavior Trees read Millington & Funge, Chapter 5.1-5.4 10/9 Applying Decision Making to BZFlag Programming Assignment 2 due 10/14 Fuzzy Logic, Markov Systems & Goal-Oriented Behavior read Millington & Funge, Chapter 5.5-5.7 10/16 Individual Presentation: Code Review 10/21 Rule-Based Systems,Blackboard Architectures,Scripting and Action Execution read Millington & Funge, Chapter 5.8-5.11 10/23 Review for Midterm Programming Assignment 3 due 10/28 Midterm Exam 10/30 Final Project Description Writing Assignment 2 draft due 11/4 Waypoint Tactics and Tactical Analyses read Millington & Funge, Chapter 6.1-6.2 11/6 Tactics in BZFlag 11/11 Holiday: Veterans Day 11/13 Tactical Pathfinding and Coordinated Action read Millington & Funge, Chapter 6.3-6.4 Writing Assignment 2 revision due 11/18 more on Tactics in BZFlag 11/20 Machine Learning read Millington & Funge, Chapter 7.1-7.3 11/25 Decision Learning with Naive Bayes Classifiers and ID3 read Millington & Funge, Chapter 7.4-7.6 11/27 Reinforcement Learning and Artificial Neural Networks read Millington & Funge, Chapter 7.7-7.8 12/2 Group Presentation: AI Techniques Used for AI Shootout 12/4 Final Project AI Shootout Final report, draft due 12/9 Review for Final Exam 12/11 Group Presentation: Post-Mortem Analysis of AI Shootout 12/16 Comprehensive Final Exam 9-11 am (no student has an exam right after the originally scheduled time of 7:30-9:30 and every student wants to move the exam, so new time) (see UHM Records & Registration for other Fall 2013 exam times). Final report, revision due David N. Chin / Chin@Hawaii.Edu