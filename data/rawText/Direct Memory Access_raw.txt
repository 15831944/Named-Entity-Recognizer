 foru800 other uses ofu800 theu800 abbreviation dmau800 dmau800 disambiguation dmau800  direct memory access   dmau800  isu800 au800 feature ofu800 modern computer computers that allows certain hardware subsystems within theu800 computer tou800 access system computer storage memory independently ofu800 theu800 central processing unit cpuu800 . without dmau800 when theu800 cpuu800 isu800 using programmed input output itu800 isu800 typically fully occupied foru800 theu800 entire duration ofu800 theu800 read oru800 write operation andu800 isu800 thus unavailable tou800 perform other work. with dmau800 theu800 cpuu800 initiates theu800 transfer does other operations while theu800 transfer isu800 inu800 progress andu800 receives anu800 interrupt from theu800 dmau800 controller when theu800 operation isu800 done. this feature isu800 useful anyu800 time theu800 cpuu800 cannot keep upu800 with theu800 rate ofu800 data transfer oru800 where theu800 cpuu800 needs tou800 perform useful work while waiting foru800 au800 relatively slow iu800 ou800 data transfer. many hardware systems useu800 dmau800 including disk drive controllers graphics card cards network card cards andu800 sound card cards. dmau800 isu800 also used foru800 intra-chip data transfer inu800 multi-core processor processors. computers that have dmau800 channels canu800 transfer data tou800 andu800 from devices with much less cpuu800 overhead than computers without dmau800 channels. similarly au800 processing element inside au800 multi-core processor canu800 transfer data tou800 andu800 from itsu800 local memory without occupying itsu800 processor time allowing computation andu800 data transfer tou800 proceed inu800 parallel. dmau800 canu800 also beu800 used foru800 memory tou800 memory copying oru800 moving ofu800 data within memory. dmau800 canu800 offload expensive memory operations such asu800 large copies oru800 vectored iu800 ou800 scatter-gather operations from theu800 cpuu800 tou800 au800 dedicated dmau800 engine. anu800 implementation example isu800 theu800 iu800 ou800 acceleration technology . principle principle principle au800 dmau800 controller canu800 generate addresses andu800 initiate memory read oru800 write cycles. itu800 contains several registers that canu800 beu800 written andu800 read byu800 theu800 cpuu800. these include au800 memory address register au800 byte count register andu800 oneu800 oru800 more control registers. theu800 control registers specify theu800 iu800 ou800 port tou800 useu800 theu800 direction ofu800 theu800 transfer reading from theu800 iu800 ou800 device oru800 writing tou800 theu800 iu800 ou800 device theu800 transfer unit byte atu800 au800 time oru800 word atu800 au800 time andu800 theu800 number ofu800 bytes tou800 transfer inu800 oneu800 burst. cite book first adam last osborne title anu800 introduction tou800 microcomputers volume 1u800 basic concepts edition 2ndu800 publisher osborne mcgraw hill year 1980 isbn 0931988349 pages 5u8e2809364 through 5u8e2809393 tou800 carry outu800 anu800 input output oru800 memory-tou800-memory operation theu800 host processor initializes theu800 dmau800 controller with au800 count ofu800 theu800 number ofu800 words tou800 transfer andu800 theu800 memory address tou800 useu800. theu800 cpuu800 then sends commands tou800 au800 peripheral device tou800 initiate transfer ofu800 data. theu800 dmau800 controller then provides addresses andu800 read write control lines tou800 theu800 system memory. each time au800 word ofu800 data isu800 ready tou800 beu800 transferred between theu800 peripheral device andu800 memory theu800 dmau800 controller increments itsu800 internal address register until theu800 full block ofu800 data isu800 transferred. dmau800 transfers canu800 either occur oneu800 word atu800 au800 time oru800 allu800 atu800 once inu800 burst mode. ifu800 they occur au800 word atu800 au800 time this canu800 allow theu800 cpuu800 tou800 access memory onu800 alternate busu800 cycles - this isu800 called cycle stealing since theu800 dmau800 controller andu800 cpuu800 contend foru800 memory access. inu800  burst mode dmau800  theu800 cpuu800 canu800 beu800 putu800 onu800 hold while theu800 dmau800 transfer occurs andu800 au800 full block ofu800 possibly hundreds oru800 thousands ofu800 words canu800 beu800 moved. cite book first paul last horowitz first2 winfield last2 hill title theu800 artu800 ofu800 electronics edition second publisher cambridge university press year 1989 isbn 0521370957 page 702u800 when memory cycles areu800 much faster than processor cycles anu800  interleaved  dmau800 cycle isu800 possible where theu800 dmau800 controller uses memory while theu800 cpuu800 cannot. inu800 au800 busu800 mastering system both theu800 cpuu800 andu800 peripherals canu800 beu800 granted control ofu800 theu800 memory busu800. where au800 peripheral canu800 become busu800 master itu800 canu800 directly write tou800 system memory without involvement ofu800 theu800 cpuu800 providing memory address andu800 control signals asu800 required. some measure must beu800 provided tou800 putu800 theu800 processor into au800 hold condition sou800 that busu800 contention does notu800 occur. modes ofu800 operation modes ofu800 operation modes ofu800 operation burst mode burst mode burst mode anu800 entire block ofu800 data isu800 transferred inu800 oneu800 contiguous sequence. once theu800 dmau800 controller isu800 granted access tou800 theu800 system busu800 byu800 theu800 cpuu800 itu800 transfers allu800 bytes ofu800 data inu800 theu800 data block before releasing control ofu800 theu800 system buses back tou800 theu800 cpuu800 butu800 renders theu800 cpuu800 inactive foru800 relatively long periods ofu800 time. theu800 mode isu800 also called block transfer mode . cycle stealing mode cycle stealing mode cycle stealing mode theu800  cycle stealing mode  isu800 used inu800 systems inu800 which theu800 cpuu800 should notu800 beu800 disabled foru800 theu800 length ofu800 time needed foru800 burst transfer modes. inu800 theu800 cycle stealing mode theu800 dmau800 controller obtains access tou800 theu800 system busu800 theu800 same wayu800 asu800 inu800 burst mode using  bru800 busu800 request andu800 bgu800 busu800 grant signals  which areu800 theu800 twou800 signals controlling theu800 interface between theu800 cpuu800 andu800 theu800 dmau800 controller. however inu800 cycle stealing mode after oneu800 byte ofu800 data transfer theu800 control ofu800 theu800 system busu800 isu800 deasserted tou800 theu800 cpuu800 viau800 bgu800. itu800 isu800 then continually requested again viau800 bru800 transferring oneu800 byte ofu800 data peru800 request until theu800 entire block ofu800 data hasu800 been transferred. byu800 continually obtaining andu800 releasing theu800 control ofu800 theu800 system busu800 theu800 dmau800 controller essentially interleaves instruction andu800 data transfers. theu800 cpuu800 processes anu800 instruction then theu800 dmau800 controller transfers oneu800 data value andu800 sou800 onu800. onu800 theu800 oneu800 hand theu800 data block isu800 notu800 transferred asu800 quickly inu800 cycle stealing mode asu800 inu800 burst mode butu800 onu800 theu800 other hand theu800 cpuu800 isu800 notu800 idled foru800 asu800 long asu800 inu800 burst mode. cycle stealing mode isu800 useful foru800 controllers that monitor data inu800 real time. transparent mode transparent mode transparent mode theu800  transparent mode  takes theu800 most time tou800 transfer au800 block ofu800 data yetu800 itu800 isu800 also theu800 most efficient mode inu800 terms ofu800 overall system performance. theu800 dmau800 controller only transfers data when theu800 cpuu800 isu800 performing operations that dou800 notu800 useu800 theu800 system buses. itu800 isu800 theu800 primary advantage ofu800 theu800 transparent mode that theu800 cpuu800 never stops executing itsu800 programs andu800 theu800 dmau800 transfer isu800 free inu800 terms ofu800 time. theu800 disadvantage ofu800 theu800 transparent mode isu800 that theu800 hardware needs tou800 determine when theu800 cpuu800 isu800 notu800 using theu800 system buses which canu800 beu800 complex. cache coherency cache coherency cache coherency file cache incoherence writeu82esvgu800 frame cache incoherence dueu800 tou800 dmau800 dmau800 canu800 lead tou800 cache coherency problems. imagine au800 cpuu800 equipped with au800 cache andu800 anu800 external memory that canu800 beu800 accessed directly byu800 devices using dmau800. when theu800 cpuu800 accesses location xu800 inu800 theu800 memory theu800 current value will beu800 stored inu800 theu800 cache. subsequent operations onu800 xu800 will update theu800 cached copy ofu800 xu800 butu800 notu800 theu800 external memory version ofu800 xu800 assuming au800 write back cache write-back cache . ifu800 theu800 cache isu800 notu800 flushed tou800 theu800 memory before theu800 next time au800 device tries tou800 access xu800 theu800 device will receive au800 stale value ofu800 xu800. similarly ifu800 theu800 cached copy ofu800 xu800 isu800 notu800 invalidated when au800 device writes au800 newu800 value tou800 theu800 memory then theu800 cpuu800 will operate onu800 au800 stale value ofu800 xu800. this issue canu800 beu800 addressed inu800 oneu800 ofu800 twou800 ways inu800 system design cache-coherent systems implement au800 method inu800 hardware whereby external writes areu800 signaled tou800 theu800 cache controller which then performs au800 cache invalidation foru800 dmau800 writes oru800 cache flush foru800 dmau800 reads. nonu800-coherent systems leave this tou800 software where theu800 osu800 must then ensure that theu800 cache lines areu800 flushed before anu800 outgoing dmau800 transfer isu800 started andu800 invalidated before au800 memory range affected byu800 anu800 incoming dmau800 transfer isu800 accessed. theu800 osu800 must make sure that theu800 memory range isu800 notu800 accessed byu800 anyu800 running threads inu800 theu800 meantime. theu800 latter approach introduces some overhead tou800 theu800 dmau800 operation asu800 most hardware requires au800 loop tou800 invalidate each cache line individually. hybrids also exist where theu800 secondary l2u800 cache isu800 coherent while theu800 l1u800 cache typically onu800-cpuu800 isu800 managed byu800 software. -- todo howu800 isu800 this problem worked around -- examples examples examples isau800 isau800 isau800 inu800 theu800 original ibmu800 pcu800 there wasu800 only oneu800 intel 8237 dmau800 controller capable ofu800 providing four dmau800 channels numbered 0u8e280933 asu800 part ofu800 theu800 sou800-called industry standard architecture oru800 isau800. these dmau800 channels performed 8u800-bitu800 transfers andu800 could only address theu800 first megabyte ofu800 ramu800. with theu800 ibmu800 pcu800 atu800 au800 second 8237 dmau800 controller wasu800 added channels 5u800&ndash;7u800; channel 4u800 isu800 unusable andu800 theu800 page register wasu800 rewired tou800 address theu800 full 16u800 mbu800 memory address space ofu800 theu800 80286 cpuu800. this second controller performed 16u800-bitu800 transfers. dueu800 tou800 their lagging performance 2u800u82e5u800 mbit su800 intel publication 03040 augu800 1989 these devices have been largely obsolete since theu800 advent ofu800 theu800 80386 processor inu800 1985 andu800 itsu800 capacity foru800 32u800-bitu800 transfers. they areu800 still supported tou800 theu800 extent they areu800 required tou800 support built-inu800 legacy pcu800 hardware onu800 modern machines. theu800 only pieces ofu800 legacy hardware that useu800 isau800 dmau800 andu800 areu800 still fairly common areu800 theu800 built-inu800 floppy disk controllers ofu800 many pcu800 mainboards andu800 those ieee 1284 parallel ports that support theu800 fast ecpu800 mode. each dmau800 channel hasu800 au800 16u800-bitu800 address register andu800 au800 16u800-bitu800 count register associated with itu800. tou800 initiate au800 data transfer theu800 device driver sets upu800 theu800 dmau800 channel channel'su800 address andu800 count registers together with theu800 direction ofu800 theu800 data transfer read oru800 write. itu800 then instructs theu800 dmau800 hardware tou800 begin theu800 transfer. when theu800 transfer isu800 complete theu800 device interrupt interrupts theu800 cpuu800. scatter-gather oru800 vectored iu800 ou800 dmau800 allows theu800 transfer ofu800 data tou800 andu800 from multiple memory areas inu800 au800 single dmau800 transaction. itu800 isu800 equivalent tou800 theu800 chaining together ofu800 multiple simple dmau800 requests. theu800 motivation isu800 tou800 offu800-load multiple input output interrupt andu800 data copy tasks from theu800 cpuu800. drqu800 stands foru800  data request ; dack foru800  data acknowledge . these symbols seen onu800 hardware schematic schematics ofu800 computer systems with dmau800 functionality represent electronic signaling lines between theu800 cpuu800 andu800 dmau800 controller. each dmau800 channel hasu800 oneu800 request andu800 oneu800 acknowledge line. au800 device that uses dmau800 must beu800 configured tou800 useu800 both lines ofu800 theu800 assigned dmau800 channel. standard isau800 dmau800 assignments dram refresh obsolete user hardware floppy disk controller hard disk obsoleted byu800 programmed input output piou800 modes andu800 replaced byu800 udma modes cascade from xtu800 dmau800 controller hard disk psu800 2u800 only user hardware foru800 allu800 others user hardware. user hardware. pciu800 pciu800 pciu800 au800 peripheral component interconnect pciu800 architecture hasu800 nou800 central dmau800 controller unlike isau800. instead anyu800 pciu800 component canu800 request control ofu800 theu800 busu800 become theu800 busu800 master andu800 request tou800 read from andu800 write tou800 system memory. more precisely au800 pciu800 component requests busu800 ownership from theu800 pciu800 busu800 controller usually theu800 southbridge computing southbridge inu800 au800 modern pcu800 design which will arbiter electronics arbitrate ifu800 several devices request busu800 ownership simultaneously since there canu800 only beu800 oneu800 busu800 master atu800 oneu800 time. when theu800 component isu800 granted ownership itu800 will issue normal read andu800 write commands onu800 theu800 pciu800 busu800 which will beu800 claimed byu800 theu800 busu800 controller andu800 will beu800 forwarded tou800 theu800 memory controller using au800 scheme which isu800 specific tou800 every chipset. asu800 anu800 example onu800 au800 modern amdu800 socket am2u800 -based pcu800 theu800 southbridge will forward theu800 transactions tou800 theu800 northbridge computing northbridge which isu800 integrated onu800 theu800 cpuu800 dieu800 using hypertransport which will inu800 turn convert them tou800 ddr2 sdram ddr2 operations andu800 send them outu800 onu800 theu800 ddr2 memory busu800. asu800 canu800 beu800 seen there areu800 quite au800 number ofu800 steps involved inu800 au800 pciu800 dmau800 transfer; however that poses little problem since theu800 pciu800 device oru800 pciu800 busu800 itself areu800 anu800 order ofu800 magnitude slower than theu800 rest ofu800 theu800 components seeu800 list ofu800 device bandwidths . au800 modern x86u800 cpuu800 mayu800 useu800 more than 4u800 gbu800 ofu800 memory utilizing physical address extension paeu800 au800 36u800-bitu800 addressing mode oru800 theu800 native 64u800-bitu800 mode ofu800 x86u800-64u800 cpus. inu800 such au800 case au800 device using dmau800 with au800 32u800-bitu800 address busu800 isu800 unable tou800 address memory above theu800 4u800 gbu800 line. theu800 newu800 double address cycle dacu800 mechanism ifu800 implemented onu800 both theu800 pciu800 busu800 andu800 theu800 device itself cite webu800 urlu800 title physical address extension&nbsp;u8e28094 paeu800 memory andu800 windows publisher microsoft windows hardware development central year 2005 accessdate 2008-04u800-07u800 enables 64u800-bitu800 dmau800 addressing. otherwise theu800 operating system would need tou800 work around theu800 problem byu800 either using costly double buffering dmau800 double buffer buffers dosu800 windows nomenclature also known asu800 bounce buffer buffers freebsd linux oru800 itu800 could useu800 anu800 iommu tou800 provide address translation services ifu800 oneu800 isu800 present. iu800 oatu800 iu800 oatu800 iu800 oatu800 main iu800 ou800 acceleration technology asu800 anu800 example ofu800 dmau800 engine incorporated inu800 au800 general-purpose cpuu800 newer intel xeon chipsets include au800 dmau800 engine technology called iu800 ou800 acceleration technology iu800 oatu800 meant tou800 improve network performance onu800 high-throughput network interfaces inu800 particular gigabit ethernet andu800 faster. cite journal last corbet first jonathan authorlink title memory copies inu800 hardware journal lwnu800u82enetu800 volume issue december 8u800 2005 pages publisher date 2005-12u800-06u800 urlu800 doiu800 idu800 accessdate 2006-11u800-12u800 however various benchmarks with this approach byu800 intel intel'su800 linux kernel developer andrew grover indicate nou800 more than 10u800 improvement inu800 cpuu800 utilization with receiving workloads andu800 nou800 improvement when transmitting data. cite webu800 first andrew last grover title iu800 oatu800 onu800 linuxnet wiki work overview ofu800 iu800 oatu800 onu800 linux with links tou800 several benchmarks date 2006-06u800-01u800 urlu800 accessdate 2006-12u800-12u800 ahbu800 ahbu800 ahbu800 main advanced microcontroller busu800 architecture inu800 system-onu800-au800-chip systems-onu800-au800-chip andu800 embedded system systems typical system busu800 infrastructure isu800 au800 complex onu800-chip busu800 such asu800 advanced microcontroller busu800 architecture#high-performance busu800 amba high-performance busu800 . amba defines twou800 kinds ofu800 ahbu800 components master andu800 slave. au800 slave interface isu800 similar tou800 programmed iu800 ou800 through which theu800 software running onu800 embedded cpuu800 eu800u82egu800. armu800 architecture armu800 canu800 write read iu800 ou800 registers oru800 less commonly local memory blocks inside theu800 device. au800 master interface canu800 beu800 used byu800 theu800 device tou800 perform dmau800 transactions tou800 from system memory without heavily loading theu800 cpuu800. therefore high bandwidth devices such asu800 network controllers that need tou800 transfer huge amounts ofu800 data tou800 from system memory will have twou800 interface adapters tou800 theu800 ahbu800 au800 master andu800 au800 slave interface. this isu800 because onu800-chip buses like ahbu800 dou800 notu800 support three-state logic triu800-stating theu800 busu800 oru800 alternating theu800 direction ofu800 anyu800 line onu800 theu800 busu800. like pciu800 nou800 central dmau800 controller isu800 required since theu800 dmau800 isu800 busu800-mastering butu800 anu800 arbiter electronics arbiter isu800 required inu800 case ofu800 multiple masters present onu800 theu800 system. internally au800 multichannel dmau800 engine isu800 usually present inu800 theu800 device tou800 perform multiple concurrent vectored iu800 ou800 scatter-gather operations asu800 programmed byu800 theu800 software. cell cell cell main cell microprocessor asu800 anu800 example usage ofu800 dmau800 inu800 au800 multiprocessor-system-onu800-chip ibmu800 sony toshiba toshiba'su800 cell microprocessor cell processor incorporates au800 dmau800 engine foru800 each ofu800 itsu800 9u800 processing elements including oneu800 power processor element ppeu800 andu800 eight synergistic processor elements spes . since theu800 speu800 speu800'su800 load store instructions canu800 read write only itsu800 ownu800 local memory anu800 speu800 entirely depends onu800 dmas tou800 transfer data tou800 andu800 from theu800 main memory andu800 local memories ofu800 other spes. thus theu800 dmau800 acts asu800 au800 primary means ofu800 data transfer among cores inside this central processing unit cpuu800 inu800 contrast tou800 cache-coherent cmpu800 architectures such asu800 intel intel'su800 cancelled gpgpu general-purpose gpuu800 larrabee microarchitecture larrabee . dmau800 inu800 cell isu800 fully #cache coherency problem cache coherent note however local stores ofu800 spes operated upon byu800 dmau800 dou800 notu800 actu800 asu800 globally coherent cache inu800 theu800 cpuu800 cache standard sense . inu800 both read getu800 andu800 write putu800 au800 dmau800 command canu800 transfer either au800 single block area ofu800 size upu800 tou800 16kb oru800 au800 list ofu800 2u800 tou800 2048 such blocks. theu800 dmau800 command isu800 issued byu800 specifying au800 pair ofu800 au800 local address andu800 au800 remote address foru800 example when au800 speu800 program issues au800 putu800 dmau800 command itu800 specifies anu800 address ofu800 itsu800 ownu800 local memory asu800 theu800 source andu800 au800 virtual memory address pointing tou800 either theu800 main memory oru800 theu800 local memory ofu800 another speu800 asu800 theu800 target together with au800 block size. according tou800 au800 recent experiment anu800 effective peak performance ofu800 dmau800 inu800 cell 3u800&nbsp;ghzu800 under uniform traffic reaches 200gb peru800 second. cite webu800 first michael last kistler title cell multiprocessor communication network work extensive benchmarks ofu800 dmau800 performance inu800 cell broadband engine date 2006-05u800 urlu800 seeu800 also seeu800 also seeu800 also atu800 attachment blitter channel iu800 ou800 dmau800 attack polling computer science remote direct memory access notes notes notes reflist 30em references references references refbegin dmau800 fundamentals onu800 various pcu800 platforms from au800. fu800. harvey andu800 data acquisition division staff national instruments mmap andu800 dmau800 from  linux device drivers 2ndu800 edition  alessandro rubini & jonathan corbet memory mapping andu800 dmau800 from  linux device drivers 3rdu800 edition  jonathan corbet alessandro rubini greg kroah-hartman dmau800 andu800 interrupt handling dmau800 modes & busu800 mastering refend computer-busu800 category computer memory category motherboard category computer storage buses 