 about computer memory paging other uses page disambiguation page inu800 computer operating system systems  paging  isu800 oneu800 ofu800 theu800 memory management memory-management schemes byu800 which au800 computer canu800 store andu800 retrieve data from computer_data_storage#secondary_storage secondary storage foru800 useu800 inu800 computer_data_storage#primary_storage main memory . inu800 theu800 paging memory-management scheme theu800 operating system retrieves data from secondary storage inu800 same-size block_ data_storage blocks called  pages . theu800 main advantage ofu800 paging over memory segmentation isu800 that itu800 allows theu800 physical address space ofu800 au800 process tou800 beu800 contiguous#computer science noncontiguous . before paging came into useu800 systems hadu800 tou800 fitu800 whole programs into storage contiguously which caused various computer data storage storage andu800 fragmentation computer fragmentation problems. cite book contribution virtual memory systems title encyclopedia ofu800 computer science andu800 technology editor1-last belzer editor1-first jack editor2-last holzman editor2-first albert gu800. editor3-last kent editor3-first allen publisher crcu800 press volume 14u800 page 32u800 year 1981 urlu800 isbn 0u800-8247-2214-0u800 postscript --none-- paging isu800 anu800 important part ofu800 virtual memory implementation inu800 most contemporary general-purpose operating systems allowing them tou800 useu800 disk storage foru800 data that does notu800 fitu800 into physical random-access memory ramu800 . overview overview overview theu800 main functions ofu800 paging areu800 performed when au800 program tries tou800 access pages that areu800 notu800 currently mapped tou800 physical memory ramu800 . this situation isu800 known asu800 au800 page fault . theu800 operating system must then take control andu800 handle theu800 page fault inu800 au800 manner invisible tou800 theu800 program. therefore theu800 operating system must # determine theu800 location ofu800 theu800 data inu800 auxiliary storage. # obtain anu800 empty page frame inu800 ramu800 tou800 useu800 asu800 au800 container foru800 theu800 data. # load theu800 requested data into theu800 available page frame. # update theu800 page table tou800 show theu800 newu800 data. # return control tou800 theu800 program transparently retrying theu800 instruction computer science instruction that caused theu800 page fault. until there isu800 notu800 enough ramu800 tou800 store allu800 theu800 data needed theu800 process ofu800 obtaining anu800 empty page frame does notu800 involve removing another page from ramu800. ifu800 allu800 page frames areu800 nonu800-empty obtaining anu800 empty page frame requires choosing au800 page frame containing data tou800 empty. ifu800 theu800 data inu800 that page frame hasu800 been modified since itu800 wasu800 read into ramu800 iu800u82eeu800. ifu800 itu800 hasu800 become dirty itu800 must beu800 written back tou800 itsu800 location inu800 secondary storage before being freed; otherwise theu800 contents ofu800 theu800 page page'su800 page frame inu800 ramu800 areu800 theu800 same asu800 theu800 contents ofu800 theu800 page inu800 secondary storage sou800 itu800 does notu800 need tou800 beu800 written back tou800 secondary storage. ifu800 au800 reference isu800 then made tou800 that page au800 page fault will occur andu800 anu800 empty page frame must beu800 obtained andu800 theu800 contents ofu800 theu800 page inu800 secondary storage again read into that page frame. efficient paging systems must determine theu800 page frame tou800 empty byu800 choosing oneu800 that isu800 least likely tou800 beu800 needed within au800 short time. there areu800 various page replacement algorithm algorithms that tryu800 tou800 dou800 this. most operating systems useu800 some approximation ofu800 theu800 least recently used lruu800 page replacement algorithm theu800 lruu800 itself cannot beu800 implemented onu800 theu800 current hardware oru800 au800 working setu800 -based algorithm. tou800 further increase responsiveness paging systems mayu800 employ various strategies tou800 predict which pages will beu800 needed soon. such systems will attempt tou800 load pages into main memory preemptively before au800 program references them. page replacement algorithms page replacement algorithms page replacement algorithms main page replacement algorithm demand paging demand paging demand paging main demand paging when pure demand paging isu800 used page loading only occurs atu800 theu800 time ofu800 theu800 data request andu800 notu800 before. inu800 particular when au800 demand pager isu800 used au800 program usually begins execution with none ofu800 itsu800 pages preu800-loaded inu800 ramu800. pages areu800 copied from theu800 executable file into ramu800 theu800 first time theu800 executing code references them usually inu800 response tou800 page fault faults. asu800 au800 consequence pages ofu800 theu800 executable file containing code notu800 executed during au800 particular runu800 will never beu800 loaded into memory. anticipatory paging anticipatory paging anticipatory paging this technique sometimes called swap prefetch preloads au800 process process'su800 nonu800-resident pages that areu800 likely tou800 beu800 referenced inu800 theu800 near future taking advantage ofu800 locality ofu800 reference . such strategies attempt tou800 reduce theu800 number ofu800 page faults au800 process experiences. some ofu800 those strategies areu800   ifu800 au800 program references oneu800 virtual address which causes au800 page fault perhaps theu800 next fewu800 pages worth ofu800 virtual address space will soon beu800 used   andu800   ifu800 oneu800 bigu800 program just finished execution leaving lots ofu800 free ramu800 perhaps theu800 user will return tou800 using some ofu800 theu800 programs that were recently paged outu800  . free page queue free page queue free page queue theu800 free page queue isu800 au800 list ofu800 page frames that areu800 available foru800 assignment after au800 page fault. some operating systems eu800u82egu800. mvsu800 support page reclamation; ifu800 au800 page fault occurs foru800 au800 page that hadu800 been stolen andu800 theu800 page frame wasu800 never reassigned then theu800 operating system avoids theu800 necessity ofu800 reading theu800 page back inu800 byu800 assigning theu800 unmodified page frame. page stealing page stealing page stealing some operating systems periodically look foru800 pages that have notu800 been recently referenced andu800 addu800 them tou800 theu800 free page queue after paging them outu800 ifu800 they have been modified. preu800-cleaning preu800-cleaning preu800-cleaning unix operating systems periodically useu800 sync unix sync tou800 preu800-clean allu800 dirty pages that isu800 tou800 save allu800 modified pages tou800 hard disk. windows operating systems dou800 theu800 same thing viau800 modified page writer threads. preu800-cleaning makes starting au800 newu800 program oru800 opening au800 newu800 data file much faster. theu800 hard drive canu800 immediately seek tou800 that file andu800 consecutively read theu800 whole file into preu800-cleaned page frames. without preu800-cleaning theu800 hard drive isu800 forced tou800 seek back andu800 forth between writing au800 dirty page frame tou800 disk andu800 then reading theu800 next page ofu800 theu800 file into that frame. thrashing thrashing thrashing main thrashing computer science most programs reach au800 steady state inu800 their demand foru800 memory locality ofu800 reference locality both inu800 terms ofu800 instructions fetched andu800 data being accessed. this steady state isu800 usually much less than theu800 total memory required byu800 theu800 program. this steady state isu800 sometimes referred tou800 asu800 theu800 working setu800 theu800 setu800 ofu800 memory pages that areu800 most frequently accessed. virtual memory systems work most efficiently when theu800 ratio ofu800 theu800 working setu800 tou800 theu800 total number ofu800 pages that canu800 beu800 stored inu800 ramu800 isu800 lowu800 enough that theu800 time spent resolving page fault faults isu800 notu800 au800 dominant factor inu800 theu800 workload workload'su800 performance. au800 program that works with huge data structures will sometimes require au800 working setu800 that isu800 toou800 large tou800 beu800 efficiently managed byu800 theu800 page system resulting inu800 constant page faults that drastically slow down theu800 system. this condition isu800 referred tou800 asu800 thrashing computer science thrashing pages areu800 swapped outu800 andu800 then accessed causing frequent faults. anu800 interesting characteristic ofu800 thrashing isu800 that asu800 theu800 working setu800 grows there isu800 very little increase inu800 theu800 number ofu800 faults until theu800 critical point when faults gou800 upu800 dramatically andu800 theu800 majority ofu800 theu800 system system'su800 processing power isu800 spent onu800 handling them . anu800 extreme example ofu800 this sort ofu800 situation occurred onu800 theu800 ibmu800 system 360u800 model 67u800 andu800 ibmu800 system 370u800 series mainframe computers inu800 which au800 particular instruction could consist ofu800 anu800 execute instruction which crosses au800 page boundary that theu800 instruction points tou800 au800 move instruction that itself also crosses au800 page boundary targeting au800 move ofu800 data from au800 source that crosses au800 page boundary tou800 au800 target ofu800 data that also crosses au800 page boundary. theu800 total number ofu800 pages thus being used byu800 this particular instruction isu800 eight andu800 allu800 eight pages must beu800 present inu800 memory atu800 theu800 same time. ifu800 theu800 operating system will allocate less than eight pages ofu800 actual memory inu800 this example when itu800 attempts tou800 swap outu800 some part ofu800 theu800 instruction oru800 data tou800 bring inu800 theu800 remainder theu800 instruction will again page fault andu800 itu800 will thrash onu800 every attempt tou800 restart theu800 failing instruction. tou800 decrease excessive paging andu800 thus possibly resolve thrashing problem au800 user canu800 dou800 anyu800 ofu800 theu800 following increase theu800 amount ofu800 ramu800 inu800 theu800 computer generally theu800 best long-term solution . decrease theu800 number ofu800 programs being concurrently runu800 onu800 theu800 computer. theu800 term  thrashing  isu800 also used inu800 contexts other than virtual memory systems foru800 example tou800 describe cache computing cache issues inu800 computing oru800 silly window syndrome inu800 networking. sharing sharing sharing inu800 multi-programming oru800 inu800 multi-user environment itu800 isu800 common foru800 many users tou800 beu800 executing theu800 same program. ifu800 individual copies ofu800 these programs were given tou800 each user much ofu800 theu800 primary storage would beu800 wasted. theu800 solution isu800 tou800 share those pages that canu800 beu800 shared. sharing must beu800 carefully controlled tou800 prevent oneu800 process from modifying data that another process isu800 accessing. inu800 most systems theu800 shared programs areu800 divided into separate pages iu800u82eeu800. coding andu800 data areu800 kept separate. this isu800 achieved byu800 having junction table page mapu800 table entries ofu800 different processes point tou800 theu800 same page frame that page frame isu800 shared among those processes. terminology terminology terminology historically  paging  sometimes referred tou800 au800 memory allocation scheme that used fixed-length pages asu800 opposed tou800 variable-length segmentation memory segments without implicit suggestion that virtual memory techniques were employed atu800 allu800 oru800 that those pages were transferred tou800 disk. cite book first harvey mu800. last deitel title anu800 introduction tou800 operating systems publisher addison-wesley pages 181u800 187u800 year 1983 isbn 0u800-201u800-14473-5u800 postscript --none-- cite book contribution operating systems title encyclopedia ofu800 computer science andu800 technology editor1-last belzer editor1-first jack editor2-last holzman editor2-first albert gu800. editor3-last kent editor3-first allen publisher crcu800 press volume 11u800 page 433u800 year 1981 urlu800 isbn 0u800-8247-2261-2u800 doiu800 10u800u82e1002 postscript --none-- such usage isu800 rare today. some modern systems useu800 theu800 term  swapping  along with  paging . historically  swapping  referred tou800 moving from tou800 secondary storage au800 whole program atu800 au800 time inu800 au800 scheme known asu800 roll-inu800 roll-outu800 . cite book contribution operating systems title encyclopedia ofu800 computer science andu800 technology editor1-last belzer editor1-first jack editor2-last holzman editor2-first albert gu800. editor3-last kent editor3-first allen publisher crcu800 press volume 11u800 page 442u800 year 1981 urlu800 isbn 0u800-8247-2261-2u800 postscript --none-- cite book first harvey gu800. last cragon title memory systems andu800 pipelined processors publisher jones andu800 bartlett publishers page 109u800 year 1996 urlu800 isbn 0u800-86720-474u800-5u800 postscript --none-- inu800 theu800 1960s after theu800 concept ofu800 virtual memory wasu800 introduced&mdash;inu800 twou800 variants either using segments oru800 pages&mdash;theu800 term  swapping  wasu800 applied tou800 moving respectively either segments oru800 pages between disk andu800 memory. today with theu800 virtual memory mostly based onu800 pages notu800 segments  swapping  became au800 fairly close synonym ofu800  paging  although with oneu800 difference. dubious paging vsu800. swapping reason swapping still refers tou800 movement ofu800 anu800 entire address space. date november 2010 inu800 systems that support memory-mapped files when au800 page fault occurs au800 page mayu800 beu800 then transferred tou800 oru800 from  anyu800  ordinary disk file notu800 necessarily au800 dedicated space.  page inu800  isu800 transferring au800 page from theu800 disk tou800 ramu800.  page outu800  isu800 transferring au800 page from ramu800 tou800 theu800 disk.  swap inu800  andu800  outu800  only refer tou800 transferring pages between ramu800 andu800 dedicated  swap space  oru800  swap file  oru800   scratch disk space  andu800 notu800 anyu800 other place onu800 disk. onu800 windows ntu800 based systems dedicated swap space isu800 known asu800 au800 page file andu800 paging swapping areu800 often used interchangeably. implementations implementations implementations ferranti atlas theu800 first computer tou800 support paging wasu800 theu800 atlas computer manchester atlas cite book last1 sumner first1 fu800. hu800. last2 haley first2 gu800. last3 chenh first3 eu800. cu800. yu800. title information processing 1962 series ifip congress proceedings chapter theu800 central control unit ofu800 theu800 'atlas computer volume proceedings ofu800 ifip congress 62u800 year 1962 publisher spartan separator postscript cite webu800 urlu800 title theu800 atlas first last author authorlink coauthors date month year work publisher department ofu800 computer science location university ofu800 manchester page pages atu800 trans_title doiu800 archiveurl archivedate accessdate quote refu800 separator postscript cite webu800 urlu800 title atlas architecture first last author authorlink coauthors date month year work atlas computer publisher atlas computer laboratory location chilton page pages atu800 trans_title doiu800 archiveurl archivedate accessdate quote refu800 separator postscript jointly developed byu800 ferranti theu800 university ofu800 manchester andu800 plessey . theu800 machine hadu800 anu800 associative content-addressable memory content-addressable memory with oneu800 entry foru800 each 512u800 word page. theu800 supervisor cite book last1 kilburn first1 tu800. last2 payne first2 ru800. bu800. last3 howarth first3 du800. ju800. title computers - keyu800 tou800 total systems control series conferences proceedings pages 279u8e28093294 chapter theu800 atlas supervisor chapterurl volume volume 20u800 proceedings ofu800 theu800 eastern joint computer conference washington du800u82ecu800. year 1961 month december publisher macmillan separator postscript handled nonu800-equivalence interruptions au800 nonu800-equivalence interruption occurs when theu800 high order bits ofu800 anu800 address dou800 notu800 match anyu800 entry inu800 theu800 associative memory. andu800 managed theu800 transfer ofu800 pages between core andu800 drum inu800 order tou800 provide au800 oneu800-level store cite journal last1 kilburn first1 tu800. last2 edwards first2 du800. bu800. gu800. last3 lanigan first3 mu800. ju800. last4 sumner first4 fu800. hu800. authorlink coauthors editor-last editor-first editor-link date year 1962 month april title oneu800-level storage system trans_title journal ireu800 transactions electronic computers volume issue series pages publisher institute ofu800 radio engineers location issn pmid pmcu800 doiu800 bibcode oclc idu800 urlu800 language format archiveurl archivedate accessdate laysummary laysource laydate quote refu800 separator postscript tou800 programs. windows 3u800u82exu800 andu800 windows 9xu800 windows 3u800u82exu800 andu800 windows 9xu800 windows 3u800u82exu800 andu800 windows 9xu800 paging hasu800 been au800 feature ofu800 microsoft windows since windows 3u800u82e0u800 inu800 1990. windows 3u800u82exu800 creates au800 hidden file named 386spartu82eparu800 oru800 win386u82eswpu800 foru800 useu800 asu800 au800 swap file. itu800 isu800 generally found inu800 theu800 root directory butu800 itu800 mayu800 appear elsewhere typically inu800 theu800 windows directory . itsu800 size depends onu800 howu800 much swap space theu800 system hasu800 au800 setting selected byu800 theu800 user under windows control panel control panel u8e28692 enhanced under virtual memory . ifu800 theu800 user moves oru800 deletes this file au800 blue screen ofu800 death blue screen will appear theu800 next time windows isu800 started with theu800 error message theu800 permanent swap file isu800 corrupt . theu800 user will beu800 prompted tou800 choose whether oru800 notu800 tou800 delete theu800 file whether oru800 notu800 itu800 exists . windows 95u800 windows 98u800 andu800 windows meu800 useu800 au800 similar file andu800 theu800 settings foru800 itu800 areu800 located under control panel u8e28692 system u8e28692 performance tabu800 u8e28692 virtual memory. windows automatically sets theu800 size ofu800 theu800 page file tou800 start atu800 1u800u82e5u800&times; theu800 size ofu800 physical memory andu800 expand upu800 tou800 3u800&times; physical memory ifu800 necessary. ifu800 au800 user runs memory-intensive applications onu800 au800 system with lowu800 physical memory itu800 isu800 preferable tou800 manually setu800 these sizes tou800 au800 value higher than default. windows ntu800 windows ntu800 windows ntu800 inu800 windows ntu800 ntu800-based versions ofu800 windows such asu800 windows xpu800 windows vista andu800 windows 7u800 theu800 file used foru800 paging isu800 named pagefileu82esysu800 . theu800 default location ofu800 theu800 page file isu800 inu800 theu800 root directory ofu800 theu800 partition where windows isu800 installed. windows canu800 beu800 configured tou800 useu800 free space onu800 anyu800 available drives foru800 pagefiles. itu800 isu800 required however foru800 theu800 boot partition iu800u82eeu800. theu800 drive containing theu800 windows directory tou800 have au800 pagefile onu800 itu800 ifu800 theu800 system isu800 configured tou800 write either kernel oru800 full memory dumps after au800 blue screen ofu800 death crash . windows uses theu800 paging file asu800 temporary storage foru800 theu800 memory dump. when theu800 system isu800 rebooted windows copies theu800 memory dump from theu800 pagefile tou800 au800 separate file andu800 frees theu800 space that wasu800 used inu800 theu800 pagefile. cite webu800 urlu800 title crash dump analysis last tsigkogiannis first ilias date december 11u800 2006 accessdate 2008-07u800-22u800 publisher msdn blogs work ilias tsigkogiannis introduction tou800 windows device drivers fragmentation fragmentation fragmentation inu800 windows default configuration theu800 pagefile isu800 allowed tou800 expand beyond itsu800 initial allocation when necessary. ifu800 this happens gradually itu800 canu800 become heavily file system fragmentation fragmented which canu800 potentially cause performance problems. cite webu800 urlu800 title windows sysinternals pagedefrag work sysinternals publisher microsoft date november 1u800 2006 accessdate 2010-12u800-20u800 theu800 common advice given tou800 avoid this isu800 tou800 setu800 au800 single locked pagefile size sou800 that windows will notu800 expand itu800. however theu800 pagefile only expands when itu800 hasu800 been filled which inu800 itsu800 default configuration isu800 150u800 theu800 total amount ofu800 physical memory. cite webu800 urlu800 title howu800 tou800 determine theu800 appropriate page file size foru800 64u800-bitu800 versions ofu800 windows server 2003 oru800 windows xpu800 mskb889654_ work knowledge base publisher microsoft date november 7u800 2007 accessdate 2007-12u800-26u800 thus theu800 total demand foru800 pagefile-backed virtual memory must exceed 250u800 ofu800 theu800 computer computer'su800 physical memory before theu800 pagefile will expand. theu800 fragmentation ofu800 theu800 pagefile that occurs when itu800 expands isu800 temporary. asu800 soon asu800 theu800 expanded regions areu800 nou800 longer inu800 useu800 atu800 theu800 next reboot ifu800 notu800 sooner theu800 additional disk space allocations areu800 freed andu800 theu800 pagefile isu800 back tou800 itsu800 original state. locking au800 page file file'su800 size canu800 beu800 problematic inu800 theu800 case that au800 windows application requests more memory than theu800 total size ofu800 physical memory andu800 theu800 page file. inu800 this case requests tou800 allocate memory fail which mayu800 cause applications andu800 system processes tou800 fail. supporters ofu800 this view will note that theu800 page file isu800 rarely read oru800 written inu800 sequential order sou800 theu800 performance advantage ofu800 having au800 completely sequential page file isu800 minimal. however itu800 isu800 generally agreed that au800 large page file will allow useu800 ofu800 memory-heavy applications andu800 there isu800 nou800 penalty except that more disk space isu800 used. theu800 extra disk space mayu800 beu800 trivial onu800 systems using current specifications iu800u82eeu800. au800 system with 3u800&nbsp;gbu800 ofu800 memory having au800 6u800 gigabyte fixed-size swap file onu800 au800 computer with au800 750u800&nbsp;gbu800 disk drive oru800 au800 system with 6u800&nbsp;gbu800 ofu800 memory 16u800&nbsp;gbu800 fixed swap andu800 2u800&nbsp;tbu800 ofu800 disk space inu800 both cases theu800 system isu800 using about 8u800 10u800 ofu800 1u800 ofu800 theu800 disk space with theu800 swap file preu800-extended tou800 maximum. defragment defragmenting theu800 page file isu800 also occasionally recommended tou800 improve performance when au800 windows system isu800 chronically using much more memory than itsu800 total physical memory. citation needed date september 2010 this view ignores theu800 fact that aside from theu800 temporary results ofu800 expansion theu800 pagefile does notu800 become fragmented over time. inu800 general performance concerns related tou800 pagefile access areu800 much more effectively dealt with byu800 adding more physical memory. unix andu800 unix-like systems unix andu800 unix-like systems unix andu800 unix-like systems unix systems andu800 other unix-like operating systems useu800 theu800 term swap tou800 describe both theu800 actu800 ofu800 moving memory pages between ramu800 andu800 disk andu800 theu800 region ofu800 au800 disk theu800 pages areu800 stored onu800. inu800 some ofu800 those systems itu800 isu800 common tou800 dedicate anu800 entire partition ofu800 au800 hard disk tou800 swapping. these partitions areu800 called  swap partitions . many systems have anu800 entire hard drive dedicated tou800 swapping separate from theu800 data drive su800 containing only au800 swap partition. au800 hard drive dedicated tou800 swapping isu800 called au800 swap drive oru800 au800 scratch drive oru800 au800 scratch disk . some ofu800 those systems only support swapping tou800 au800 swap partition; others also support swapping tou800 files. linux linux linux from au800 software point ofu800 view with theu800 2u800u82e6u800 linux kernel swap files areu800 just asu800 fast cite webu800 urlu800 title jesper juhl reu800 howu800 tou800 send au800 break - dump from frozen 64bit linux publisher lkml date 2006-05u800-29u800 accessdate 2010-10u800-28u800 cite webu800 urlu800 title andrew morton reu800 swap partition vsu800 swap file publisher lkml date accessdate 2010-10u800-28u800 asu800 swap partitions. theu800 kernel keeps au800 mapu800 ofu800 where theu800 swap file exists andu800 accesses theu800 disk directly bypassing caching andu800 filesystem overhead. redu800 hatu800 recommends using au800 swap partition. chapter 7u800. swap space - redu800 hatu800 customer portal swap space canu800 beu800 au800 dedicated swap partition recommended au800 swap file oru800 au800 combination ofu800 swap partitions andu800 swap files. with au800 swap partition oneu800 canu800 choose where onu800 theu800 disk itu800 resides andu800 place itu800 where theu800 disk throughput isu800 highest. theu800 administrative flexibility ofu800 swap files canu800 outweigh theu800 other advantages ofu800 swap partitions. foru800 example au800 swap file canu800 beu800 placed onu800 anyu800 drive canu800 beu800 setu800 tou800 anyu800 desired size andu800 canu800 beu800 added oru800 changed asu800 needed. au800 swap  partition  however isu800 notu800 asu800 flexible asu800 au800 file asu800 itu800 cannot beu800 changed without using tools tou800 resize itu800 generally outside theu800 operating system that uses theu800 swap partition. linux supports using au800 virtually unlimited number ofu800 swapping devices each ofu800 which canu800 beu800 assigned au800 priority. when theu800 operating system needs tou800 swap pages outu800 ofu800 physical memory itu800 uses theu800 highest-priority device with free space. ifu800 multiple devices areu800 assigned theu800 same priority they areu800 used inu800 au800 fashion similar tou800 level 0u800 redundant array ofu800 independent disks raid arrangements. this provides improved performance asu800 long asu800 theu800 devices canu800 beu800 accessed efficiently inu800 parallel. therefore care should beu800 taken assigning theu800 priorities. foru800 example swaps located onu800 theu800 same physical disk should notu800 beu800 used inu800 parallel butu800 inu800 order ranging from theu800 fastest tou800 theu800 slowest iu800u82eeu800. theu800 fastest having theu800 highest priority . osu800 xu800 osu800 xu800 osu800 xu800 osu800 xu800 uses multiple swap files. theu800 default andu800 apple-recommended installation places them onu800 theu800 root partition though itu800 isu800 possible tou800 place them instead onu800 au800 separate partition oru800 device. cite webu800 urlu800 title macu800 osu800 xu800 10u800u82e1u800 author john siracusa publisher arsu800 technica date october 15u800 2001 accessdate 2008-07u800-23u800 solaris solaris solaris solaris operating system solaris allows swapping tou800 rawu800 disk slices asu800 well asu800 files. theu800 traditional method isu800 tou800 useu800 slice 1u800 iu800u82eeu800. theu800 second slice onu800 theu800 osu800 disk tou800 house swap. swap setup isu800 managed byu800 theu800 system boot process ifu800 there areu800 entries inu800 theu800 vfstab file butu800 canu800 also beu800 managed manually through theu800 useu800 ofu800 theu800 swap command. while itu800 isu800 possible tou800 remove atu800 runtime allu800 swap from au800 lightly loaded system sunu800 does notu800 recommend itu800. citation needed date january 2011 recent additions tou800 theu800 zfsu800 file system allow creation ofu800 zfsu800 devices that canu800 beu800 used asu800 swap partitions. swapping tou800 normal files onu800 zfsu800 file systems isu800 notu800 supported. citation needed date january 2011 amigaos 4u800 amigaos 4u800 amigaos 4u800 amigaos 4u800u82e0u800 introduced au800 newu800 system foru800 allocating ramu800 andu800 defragmenting physical memory. itu800 still uses flat shared address space that cannot beu800 defragmented. itu800 isu800 based onu800 slab allocation slab allocation method andu800 paging memory that allows swapping. paging wasu800 implemented inu800 amigaos 4u800u82e1u800 butu800 mayu800 lock upu800 system ifu800 allu800 physical memory isu800 used upu800. cite webu800 urlu800 title reu800 swap issue also onu800 update 4u800 author amigaos core developer publisher hyperion entertainment date 2011-01u800-08u800 accessdate 2011-01u800-08u800 swap memory could beu800 activated andu800 deactivated anyu800 moment allowing theu800 user tou800 choose tou800 useu800 only physical ramu800. performance performance performance theu800 backing store foru800 au800 virtual memory operating system isu800 typically many orders ofu800 magnitude mathematics magnitude slower than random access memory ramu800 . additionally using mechanical storage devices introduces access time delay several milliseconds foru800 au800 harddisk. therefore itu800 isu800 desirable tou800 reduce oru800 eliminate swapping where practical. some operating systems offer settings tou800 influence theu800 kernel kernel'su800 decisions. # linux offers theu800 proc sysu800 vmu800 swappiness parameter which changes theu800 balance between swapping outu800 runtime memory asu800 opposed tou800 dropping pages from theu800 system page cache . # windows 2000 xpu800 andu800 vista offer theu800 disablepagingexecutive registry setting which controls whether kernel-mode code andu800 data canu800 beu800 eligible foru800 paging outu800. # mainframe computers frequently used head-peru800-track disk drives oru800 drums foru800 page andu800 swap storage tou800 eliminate seek time andu800 several technologies eu800u82egu800. rotational position sensing onu800 au800 block multiplexor channel tou800 have multiple concurrent requests tou800 theu800 same device inu800 order tou800 reduce rotational latency . # flash memory hasu800 au800 finite number ofu800 erase-write cycles seeu800 flash memory#limitations limitations ofu800 flash memory andu800 theu800 smallest amount ofu800 data that canu800 beu800 erased atu800 once might beu800 very large 128u800 kibu800 foru800 anu800 intel x25u800-mu800 ssdu800 cite webu800 urlu800 title aligning filesystems tou800 anu800 ssdu8e28099s erase block size &#124u800; thoughts byu800 tedu800 publisher thunku82eorgu800 date 2009-02u800-20u800 accessdate 2010-10u800-28u800 seldom coinciding with pagesize. therefore flash memory mayu800 wear outu800 quickly ifu800 used asu800 swap space under tight memory conditions. onu800 theu800 attractive side flash memory isu800 practically delayless compared tou800 harddisks andu800 notu800 volatile memory volatile asu800 ramu800 chips. schemes like readyboost andu800 intel turbo memory areu800 made tou800 exploit these characteristics. many unix-like operating systems foru800 example aixu800 linux andu800 solaris operating system solaris allow using multiple storage devices foru800 swap space inu800 parallel tou800 increase performance. tuning swap space size tuning swap space size tuning swap space size inu800 some older virtual memory operating systems space inu800 swap backing store isu800 reserved when programs allocate memory foru800 runtime data. osu800 vendors typically issue guidelines about howu800 much swap space should beu800 allocated. reliability reliability reliability swapping canu800 decrease system reliability byu800 some amount. ifu800 swapped data gets corrupted onu800 theu800 disk oru800 atu800 anyu800 other location oru800 during transfer theu800 memory will also have incorrect contents after theu800 data hasu800 later been returned. citation needed date june 2013 addressing limits onu800 32u800-bitu800 hardware addressing limits onu800 32u800-bitu800 hardware addressing limits onu800 32u800-bitu800 hardware paging isu800 oneu800 wayu800 ofu800 allowing theu800 size ofu800 theu800 addresses used byu800 au800 processu8e28094the process process'su800 virtual address space oru800 logical address space -- tou800 beu800 different from theu800 amount ofu800 main memory actually installed onu800 au800 particular computeru8e28094the physical address space. main memory smaller than virtual memory main memory smaller than virtual memory main memory smaller than virtual memory inu800 most systems theu800 size ofu800 au800 process process'su800 virtual address space isu800 much larger than theu800 available main memory. bill buzbee. magic-1u800 minix demand paging design . inu800 these systems theu800 amount ofu800 main memory used byu800 au800 process isu800 atu800 most theu800 amount ofu800 physical main memory available. theu800 amount ofu800 physical main memory available isu800 limited byu800 theu800 number ofu800 address bits onu800 theu800 address busu800 that connects theu800 cpuu800 tou800 main memoryu8e28094for example theu800 32u800-bitu800 clean 68000 cpuu800 andu800 theu800 intel_80386#the_i386sx_variant i386sx cpuu800 both internally useu800 32u800-bitu800 virtual addresses butu800 both have only 24u800 pins connected tou800 theu800 address busu800 limiting addressing tou800 atu800 most 16u800&nbsp;mbu800 ofu800 physical main memory. even onu800 systems that have theu800 same oru800 more physical address bits asu800 virtual address bits often theu800 actual amount ofu800 physical main memory installed isu800 much less than theu800 size that canu800 potentially beu800 addressed foru800 financial reasons oru800 because theu800 hardware address mapu800 reserves large regions foru800 iu800 ou800 oru800 other hardware features sou800 main memory cannot beu800 placed inu800 those regions. main memory theu800 same size asu800 virtual memory main memory theu800 same size asu800 virtual memory main memory theu800 same size asu800 virtual memory itu800 isu800 notu800 uncommon tou800 find 32u800-bitu800 computers with 4u800&nbsp;gbu800 ofu800 ramu800 theu800 maximum amount ofu800 ramu800 addressable unless theu800 page table entry format supports physical addresses larger than 32u800 bits. foru800 example onu800 32u800-bitu800 x86u800 processors theu800 physical address extension paeu800 feature isu800 required tou800 access more than 4u800&nbsp;gbu800 ofu800 ramu800. foru800 some machines eu800u82egu800. theu800 ibmu800 ibmu800 system 370u800 su800 370u800 inu800 xau800 mode theu800 upper bitu800 wasu800 notu800 part ofu800 theu800 address andu800 only 2u800&nbsp;gbu800 could beu800 addressed. paging andu800 swap space canu800 beu800 used beyond this 4u800&nbsp;gbu800 limit dueu800 tou800 itu800 being addressed inu800 terms ofu800 disk locations rather than memory addresses. while 32u800-bitu800 programs onu800 machines with linear address spaces will continue tou800 beu800 limited tou800 theu800 4u800&nbsp;gbu800 they'reu800 capable ofu800 addressing because they each exist inu800 their ownu800 virtual address space au800 group ofu800 programs canu800 together grow beyond this limit. onu800 machines with segment registers eu800u82egu800. theu800 access registers onu800 anu800 ibmu800 system 370u800 inu800 ibmu800 esau800 390u800 esau800 mode cite manual author ibmu800 title ibmu800 system 370u800 extended architecture principles ofu800 operation idu800 sa22-7085-1u800 version second edition date january 1987 separator theu800 address space size isu800 limited only byu800 osu800 constraints eu800u82egu800. theu800 need tou800 fitu800 theu800 mapping tables into theu800 available storage. main memory larger than virtual address space main memory larger than virtual address space main memory larger than virtual address space au800 fewu800 computers have au800 main memory larger than theu800 virtual address space ofu800 au800 process such asu800 theu800 magic-1u800 some pdpu800-11u800#decline pdpu800-11u800 machines andu800 some 32u800-bitu800 processors with physical address extension . this nullifies theu800 main advantage ofu800 virtual memory since au800 single process canu800'tu800 useu800 more main memory than theu800 amount ofu800 itsu800 virtual address space. such systems often useu800 paging techniques tou800 obtain secondary benefits theu800 extra memory canu800 beu800 used inu800 theu800 page cache tou800 cache frequently used files andu800 metadata such asu800 directory information from secondary storage. ifu800 theu800 processor andu800 operating system support multiple virtual address spaces theu800 extra memory canu800 beu800 used tou800 runu800 more processes. paging allows theu800 cumulative total ofu800 virtual address spaces tou800 exceed physical main memory. theu800 size ofu800 theu800 cumulative total ofu800 virtual address spaces isu800 still limited byu800 theu800 amount ofu800 secondary storage available. seeu800 also seeu800 also seeu800 also wikisource theu800 paging game physical memory au800 subject ofu800 paging virtual memory anu800 abstraction that paging mayu800 create demand paging au800 lazy paging scheme page cache au800 disk cache that utilizes virtual memory mechanism page replacement algorithm segmentation memory page size page table memory allocation expanded memory notes notes notes reflist group nbu800 references references references reflist 2u800 external links external links external links windows server - moving pagefile tou800 another partition oru800 disk byu800 david nudelman howu800 virtual memory works from howstuffworksu82ecomu800 inu800 fact explains only swapping concept andu800 notu800 virtual memory concept linux swap space management outdated asu800 theu800 author admits guide onu800 optimizing virtual memory speed outdated andu800 contradicts section 1u800u82e4u800 ofu800 this wiki page andu800 atu800 least references 8u800 9u800 andu800 11u800. virtual memory page replacement algorithms windows xpu800. howu800 tou800 manually change theu800 size ofu800 theu800 virtual memory paging file windows xpu800. factors that mayu800 deplete theu800 supply ofu800 paged pool memory swapfs driver that canu800 beu800 used tou800 save theu800 paging file ofu800 windows onu800 au800 swap partition ofu800 linux. operating system memory management navbox category virtual memory category memory management fru800 mu8c3a9moire virtuelle#mu8c3a9moire virtuelle paginu8c3a9e 