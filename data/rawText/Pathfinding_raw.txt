 refimprove date january 2013 tree search algorithm image pathfinding 2du800 illustrationu82esvgu800 250px thumb right equivalent paths between au800 andu800 bu800 inu800 au800 2du800 environment  pathfinding  oru800  pathing  isu800 theu800 plotting byu800 au800 computer application ofu800 theu800 shortest route between twou800 points. itu800 isu800 au800 more practical variant onu800 maze#solving mazes solving mazes . this field ofu800 research isu800 based heavily onu800 dijkstra dijkstra'su800 algorithm foru800 finding theu800 shortest path onu800 au800 glossary_of_graph_theory#weighted_graphs_and_networks weighted graph . algorithms algorithms algorithms atu800 itsu800 core au800 pathfinding method searches au800 graph data structure graph byu800 starting atu800 oneu800 vertex graph theory vertex andu800 exploring adjacent node computer science node nodes until theu800 destination node isu800 reached generally with theu800 intent ofu800 finding theu800 shortest route. although graph searching methods such asu800 au800 breadth-first search would find au800 route ifu800 given enough time other methods which explore theu800 graph would tend tou800 reach theu800 destination sooner. anu800 analogy would beu800 au800 person walking across au800 room; rather than examining every possible route inu800 advance theu800 person would generally walk inu800 theu800 direction ofu800 theu800 destination andu800 only deviate from theu800 path tou800 avoid anu800 obstruction andu800 make deviations asu800 minor asu800 possible. twou800 primary problems ofu800 pathfinding areu800 tou800 find au800 path between twou800 nodes inu800 au800 graph data structure graph andu800 tou800 find theu800 shortest path problem optimal shortest path . basic algorithms such asu800 breadth-first search breadth-first andu800 depth-first search depth-first search address theu800 first problem byu800 brute-force search exhausting allu800 possibilities; starting from theu800 given node they iterate over allu800 potential paths until they reach theu800 destination node. these algorithms runu800 inu800 ou800 vu800 eu800 oru800 linear time where vu800 isu800 theu800 number ofu800 vertices andu800 eu800 isu800 theu800 number ofu800 edge graph theory edges between vertices. theu800 more complicated problem isu800 finding theu800 optimal path. theu800 exhaustive approach inu800 this case isu800 known asu800 theu800 bellmanu8e28093ford algorithm which yields au800 time complexity ofu800 ou800 vu800 eu800 oru800 quadratic time. however itu800 isu800 notu800 necessary tou800 examine allu800 possible paths tou800 find theu800 optimal oneu800. algorithms such asu800 au800 search algorithm au800 andu800 dijkstra dijkstra'su800 algorithm strategically eliminate paths either through heuristic computer science heuristics oru800 through dynamic programming . byu800 eliminating impossible paths these algorithms canu800 achieve time complexities asu800 lowu800 asu800 ou800 eu800 logu800 vu800 . theu800 above algorithms areu800 among theu800 best general algorithms which operate onu800 au800 graph without preprocessing. however inu800 practical travel-routing systems even better time complexities canu800 beu800 attained byu800 algorithms which canu800 preu800-process theu800 graph tou800 attain better performance. cite book chapter engineering route planning algorithms author delling du800. andu800 sanders pu800. andu800 schultes du800. andu800 wagner du800. title algorithmics ofu800 large andu800 complex networks pages 117u8e28093139 year 2009 publisher springer doiu800 10u800u82e1007 978u800-3u800-642u800-02094-0_7u800 oneu800 such algorithm isu800 contraction hierarchies . dijkstra dijkstra'su800 algorithm dijkstra dijkstra'su800 algorithm dijkstra dijkstra'su800 algorithm au800 common example ofu800 au800 graph-based pathfinding algorithm isu800 dijkstra dijkstra'su800 algorithm . this algorithm begins with au800 start node andu800 anu800 open setu800 ofu800 candidate nodes. atu800 each step theu800 node inu800 theu800 open setu800 with theu800 lowest distance from theu800 start isu800 examined. theu800 node isu800 marked closed andu800 allu800 nodes adjacent tou800 itu800 areu800 added tou800 theu800 open setu800 ifu800 they have notu800 already been examined. this process repeats until au800 path tou800 theu800 destination hasu800 been found. since theu800 lowest distance nodes areu800 examined first theu800 first time theu800 destination isu800 found theu800 path tou800 itu800 will beu800 theu800 shortest path. dijkstra dijkstra'su800 algorithm fails ifu800 there isu800 au800 negative edge graph theory edge weight. inu800 theu800 hypothetical situation where nodes au800 bu800 andu800 cu800 form au800 connected undirected graph with edges abu800 3u800 acu800 4u800 andu800 bcu800 u8e288922 theu800 optimal path from au800 tou800 cu800 costs 1u800 andu800 theu800 optimal path from au800 tou800 bu800 costs 2u800. dijkstra dijkstra'su800 algorithm starting from au800 will first examine bu800 asu800 that isu800 theu800 closest. itu800 will assign au800 cost ofu800 3u800 tou800 itu800 andu800 mark itu800 closed meaning that itsu800 cost will never beu800 reevaluated. therefore dijkstra dijkstra'su800 cannot evaluate negative edge weights. however since foru800 many practical purposes there will never beu800 au800 negative edgeweight dijkstra dijkstra'su800 algorithm isu800 largely suitable foru800 theu800 purpose ofu800 pathfinding. au800 algorithm au800 algorithm au800 algorithm au800 isu800 au800 variant ofu800 dijkstra dijkstra'su800 algorithm commonly used inu800 games. au800 assigns au800 weight tou800 each open node equal tou800 theu800 weight ofu800 theu800 edge tou800 that node plus theu800 approximate distance between that node andu800 theu800 finish. this approximate distance isu800 found byu800 theu800 heuristic computer science heuristic andu800 represents au800 minimum possible distance between that node andu800 theu800 endu800. this allows itu800 tou800 eliminate longer paths once anu800 initial path isu800 found. ifu800 there isu800 au800 path ofu800 length xu800 between theu800 start andu800 finish andu800 theu800 minimum distance between au800 node andu800 theu800 finish isu800 greater than xu800 that node need notu800 beu800 examined. au800 uses this heuristic tou800 improve onu800 theu800 behavior relative tou800 dijkstra dijkstra'su800 algorithm. when theu800 heuristic evaluates tou800 zero au800 isu800 equivalent tou800 dijkstra dijkstra'su800 algorithm. asu800 theu800 heuristic estimate increases andu800 gets closer tou800 theu800 true distance au800 continues tou800 find optimal paths butu800 runs faster byu800 virtue ofu800 examining fewer nodes . when theu800 value ofu800 theu800 heuristic isu800 exactly theu800 true distance au800 examines theu800 fewest nodes. however itu800 isu800 generally impractical tou800 write au800 heuristic function that always computes theu800 true distance. asu800 theu800 value ofu800 theu800 heuristic increases au800 examines fewer nodes butu800 nou800 longer guarantees anu800 optimal path. inu800 many applications such asu800 video games this isu800 acceptable andu800 even desirable inu800 order tou800 keep theu800 algorithm running quickly. sample algorithm sample algorithm sample algorithm this isu800 au800 fairly simple andu800 easy-tou800-understand pathfinding algorithm foru800 tile-based maps. tou800 start offu800 youu800 have au800 mapu800 au800 start coordinate andu800 au800 destination coordinate. theu800 mapu800 will look like this xu800 being walls su800 being theu800 start 0u800 being theu800 finish andu800 _u800 being open spaces theu800 numbers along theu800 topu800 andu800 right edges areu800 theu800 column andu800 rowu800 numbers 1u800 2u800 3u800 4u800 5u800 6u800 7u800 8u800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 _u800 _u800 _u800 xu800 xu800 _u800 xu800 _u800 xu800 1u800 xu800 _u800 xu800 _u800 _u800 xu800 _u800 _u800 _u800 xu800 2u800 xu800 su800 xu800 xu800 _u800 _u800 _u800 xu800 _u800 xu800 3u800 xu800 _u800 xu800 _u800 _u800 xu800 _u800 _u800 _u800 xu800 4u800 xu800 _u800 _u800 _u800 xu800 xu800 _u800 xu800 _u800 xu800 5u800 xu800 _u800 xu800 _u800 _u800 xu800 _u800 xu800 _u800 xu800 6u800 xu800 _u800 xu800 xu800 _u800 _u800 _u800 xu800 _u800 xu800 7u800 xu800 _u800 _u800 0u800 _u800 xu800 _u800 _u800 _u800 xu800 8u800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 first create au800 list ofu800 coordinates which weu800 will useu800 asu800 au800 queue. theu800 queue will beu800 initialized with oneu800 coordinate theu800 endu800 coordinate. each coordinate will also have au800 counter variable attached theu800 purpose ofu800 this will soon become evident . thus theu800 queue starts offu800 asu800 3u800 8u800 0u800 . then gou800 through every element inu800 theu800 queue including elements added tou800 theu800 endu800 over theu800 course ofu800 theu800 algorithm andu800 tou800 each element dou800 theu800 following # create au800 list ofu800 theu800 four adjacent cells with au800 counter variable ofu800 theu800 current element element'su800 counter variable 1u800 inu800 ouru800 example theu800 four cells areu800 2u800 8u800 1u800 3u800 7u800 1u800 4u800 8u800 1u800 3u800 9u800 1u800 # check allu800 cells inu800 each list foru800 theu800 following twou800 conditions ## ifu800 theu800 cell isu800 au800 wall remove itu800 from theu800 list ## ifu800 there isu800 anu800 element inu800 theu800 main list with theu800 same coordinate andu800 anu800 equal oru800 higher counter remove itu800 from theu800 list # addu800 allu800 remaining cells inu800 theu800 list tou800 theu800 endu800 ofu800 theu800 main list # gou800 tou800 theu800 next item inu800 theu800 list thus after turn 1u800 theu800 list ofu800 elements isu800 this 3u800 8u800 0u800 2u800 8u800 1u800 4u800 8u800 1u800 after 2u800 turns 3u800 8u800 0u800 2u800 8u800 1u800 4u800 8u800 1u800 1u800 8u800 2u800 4u800 7u800 2u800 after 3u800 turns ... 1u800 7u800 3u800 4u800 6u800 3u800 5u800 7u800 3u800 after 4u800 turns ... 1u800 6u800 4u800 3u800 6u800 4u800 6u800 7u800 4u800 after 5u800 turns ... 1u800 5u800 5u800 3u800 5u800 5u800 6u800 6u800 5u800 6u800 8u800 5u800 after 6u800 turns ... 1u800 4u800 6u800 2u800 5u800 6u800 3u800 4u800 6u800 6u800 5u800 6u800 7u800 8u800 6u800 after 7u800 turns 1u800 3u800 7u800 u8e28093 problem solved endu800 this stage ofu800 theu800 algorithm u8e28093 note that ifu800 youu800 have multiple units chasing theu800 same target asu800 inu800 many games u8e28093 theu800 finish tou800 start approach ofu800 theu800 algorithm isu800 intended tou800 make this easier youu800 canu800 continue until theu800 entire mapu800 isu800 taken upu800 allu800 units areu800 reached oru800 au800 setu800 counter limit isu800 reached nowu800 mapu800 theu800 counters onto theu800 mapu800 getting this 1u800 2u800 3u800 4u800 5u800 6u800 7u800 8u800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 _u800 _u800 _u800 xu800 xu800 _u800 xu800 _u800 xu800 1u800 xu800 _u800 xu800 _u800 _u800 xu800 _u800 _u800 _u800 xu800 2u800 xu800 su800 xu800 xu800 _u800 _u800 _u800 xu800 _u800 xu800 3u800 xu800 6u800 xu800 6u800 _u800 xu800 _u800 _u800 _u800 xu800 4u800 xu800 5u800 6u800 5u800 xu800 xu800 6u800 xu800 _u800 xu800 5u800 xu800 4u800 xu800 4u800 3u800 xu800 5u800 xu800 _u800 xu800 6u800 xu800 3u800 xu800 xu800 2u800 3u800 4u800 xu800 _u800 xu800 7u800 xu800 2u800 1u800 0u800 1u800 xu800 5u800 6u800 _u800 xu800 8u800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 xu800 nowu800 start atu800 su800 7u800 andu800 gou800 tou800 theu800 nearby cell with theu800 lowest number unchecked cells cannot beu800 moved tou800 . theu800 path traced isu800 1u800 3u800 7u800 - 1u800 4u800 6u800 - 1u800 5u800 5u800 - 1u800 6u800 4u800 - 1u800 7u800 3u800 - 1u800 8u800 2u800 - 2u800 8u800 1u800 - 3u800 8u800 0u800 . inu800 theu800 event that twou800 numbers areu800 equally lowu800 foru800 example ifu800 su800 wasu800 atu800 2u800 5u800 pick au800 random direction u8e28093 theu800 lengths areu800 theu800 same. theu800 algorithm isu800 nowu800 complete. inu800 video games inu800 video games inu800 video games pathfinding inu800 theu800 context ofu800 video game games concerns theu800 wayu800 inu800 which au800 moving entity finds au800 path around anu800 obstacle; theu800 most frequent context isu800 real-time strategy games inu800 which theu800 player directs units around au800 play area containing obstacles butu800 forms ofu800 this areu800 found inu800 most modern video games. pathfinding hasu800 grown inu800 importance asu800 games andu800 their environments have become more complex andu800 asu800 au800 result many game artificial intelligence aiu800 software packages have been developed tou800 solve theu800 problem. real-time strategy games typically contain large areas ofu800 open terrain which isu800 often relatively simple tou800 route across although itu800 isu800 common foru800 more than oneu800 unit tou800 travel simultaneously; this creates au800 need foru800 different andu800 often significantly more complex algorithms tou800 avoid traffic jams atu800 choke-points inu800 terrain oru800 when units come into contact with each other. inu800 strategy games theu800 mapu800 isu800 normally divided into tiles which actu800 asu800 nodes inu800 theu800 pathfinding algorithm. more open endedly structured genres such asu800 first-person shooter shooters often have more enclosed oru800 au800 mixture ofu800 open andu800 enclosed areas that areu800 notu800 asu800 simply divided into nodes which hasu800 given rise tou800 theu800 useu800 ofu800 navigation mesh meshes. these areu800 constructed byu800 placing nodes inu800 theu800 game world that store details ofu800 which nodes areu800 accessible from itu800. algorithms used inu800 pathfinding algorithms used inu800 pathfinding algorithms used inu800 pathfinding dijkstra dijkstra'su800 algorithm au800 search algorithm du800 au800 family ofu800 dynamic pathfinding algorithms foru800 problems inu800 which constraints vary over time references references references reflist external links external links external links straightedge open source java 2du800 path finding using au800 andu800 lighting project. includes applet demos. python-pathfinding open source python 2du800 path finding using dijkstra dijkstra'su800 algorithm andu800 lighting project. category game artificial intelligence 