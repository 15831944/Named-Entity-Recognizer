 useu800 dmyu800 dates date august 2012 infobox file format name bzip2 extension .bz2u800 mime application xu800-bzip2 uniform type publicu82earchiveu82ebzip2 owner julian seward type code bzp2 magic bzhu800 genre data compression container foru800 contained byu800 extended from extended tou800 free yesu800 infobox software name bzip2 logo bzip2-logo 80px logo screenshot caption developer julian seward latest release version 1u800u82e0u800u82e6u800 latest release date release date dfu800 yesu800 2010 09u800 20u800 operating system cross-platform genre data compression license bsdu800-like license cite webu800 publisher julian seward urlu800 title bzip2 home accessdate 2008-09u800-27u800 quote whyu800 would iu800 want tou800 useu800 itu800 .. because itu800 itu800'su800 open-source bsdu800-style license andu800 asu800 faru800 asu800 iu800 know patent-free. website urlu800 bzipu82eorgu800 lowercase title bzip2  bzip2  isu800 au800 free software free andu800 open-source software open source file compressor that uses theu800 burrowsu8e28093wheeler transform burrowsu8e28093wheeler algorithm . itu800 isu800 developed andu800 maintained byu800 julian seward . seward made theu800 first public release ofu800 bzip2 version 0u800u82e15u800 inu800 july 1996. theu800 compressor compressor'su800 stability andu800 popularity grew over theu800 next several years andu800 seward released version 1u800u82e0u800 inu800 late 2000. like gzip itu800 isu800 only au800 compressor foru800 single files andu800 notu800 au800 full archiver. compression efficiency compression efficiency compression efficiency bzip2 compresses most files more effectively than theu800 older lempelu8e28093zivu8e28093welch lzwu800 compress .zu800 andu800 deflate deflate zipu800 file format .zipu800 andu800 gzip .gzu800 compression algorithms butu800 isu800 considerably slower. lempelu8e28093zivu8e28093markov chain algorithm lzma isu800 generally more space-efficient than bzip2 atu800 theu800 expense ofu800 slower compression speed while having much faster decompression. bzip2 compresses data inu800 blocks ofu800 size between 100u800 andu800 900u800 kilobyte kbu800 andu800 uses theu800 burrowsu8e28093wheeler transform tou800 convert frequently-recurring character sequences into strings ofu800 identical letters. itu800 then applies move-tou800-front transform andu800 huffman coding . bzip2 bzip2'su800 ancestor  bzip  used arithmetic coding instead ofu800 huffman. theu800 change wasu800 made because ofu800 au800 software patent restriction. wayback dfu800 yesu800 urlu800 title theu800 bzip2 home page date 19980704181204 - section howu800 does itu800 relate tou800 your previous offering bzip-0u800u82e21u800 bzip2 performance isu800 asymmetric asu800 decompression isu800 relatively fast. motivated byu800 theu800 large cpuu800 time required foru800 compression au800 modified version wasu800 created inu800 2003 called pbzip2 that supported thread computer science multi-threading giving almost linear speed improvements onu800 multi-cpuu800 andu800 multi-core computers. cite webu800 urlu800 title bzip2 vsu800 pbzip2 onu800 quad-core asu800 ofu800 2010 5u800 this functionality hasu800 notu800 been incorporated into theu800 main project. like gzip bzip2 isu800 only au800 data compressor. itu800 isu800 notu800 anu800 archiver like raru800 oru800 zipu800; theu800 program itself hasu800 nou800 facilities foru800 multiple files encryption oru800 archive-splitting butu800 inu800 theu800 unix philosophy unix tradition relies instead onu800 separate external utilities such asu800 taru800 file format taru800 andu800 gnuu800 privacy guard gnupg foru800 these tasks. compression stack compression stack compression stack bzip2 uses several layers ofu800 compression techniques stacked onu800 topu800 ofu800 each other which occur inu800 theu800 following order during compression andu800 theu800 reverse order during decompression # runu800-length encoding rleu800 anyu800 sequence ofu800 4u800 tou800 255u800 consecutive duplicate symbols isu800 replaced byu800 theu800 first four symbols andu800 au800 repeat length between 0u800 andu800 251u800. thus theu800 sequence aaaaaaabbbbcccd isu800 replaced with aaaa 3bbbb 0cccd . runs ofu800 symbols areu800 always transformed after four consecutive symbols even ifu800 theu800 runu800-length isu800 setu800 tou800 zero tou800 keep theu800 transformation reversible. inu800 theu800 worst case itu800 canu800 cause anu800 expansion ofu800 1u800u82e25u800 andu800 best case au800 reduction tou800 0u800u82e02u800 . while theu800 specification theoretically allows foru800 runs ofu800 length 256u8e28093259 tou800 beu800 encoded theu800 reference encoder will notu800 produce such output. theu800 author ofu800 bzip2 hasu800 stated that theu800 rleu800 step wasu800 au800 historical mistake andu800 wasu800 only intended tou800 protect theu800 original bwtu800 implementation from pathological cases. bzip2 -- botu800 generated title -- # burrowsu8e28093wheeler transform bwtu800 this isu800 theu800 reversible block-sort that isu800 atu800 theu800 core ofu800 bzip2. theu800 block isu800 entirely self-contained with input andu800 output buffers remaining theu800 same sizeu8e28094in bzip2 theu800 operating limit foru800 this stage isu800 nowrap 900u800 kbu800. foru800 theu800 block-sort au800 notional matrix isu800 created inu800 which rowu800 iu800 contains theu800 whole ofu800 theu800 buffer rotated tou800 start from theu800 iu800 mathrm thu800 symbol. following rotation theu800 rows ofu800 theu800 matrix areu800 sorted into alphabetic numerical order. au800 24u800-bitu800 pointer isu800 stored marking theu800  starting position  foru800 when theu800 block isu800 untransformed. inu800 practice itu800 isu800 notu800 necessary tou800 construct theu800 full matrix; rather theu800 sort isu800 performed using pointers foru800 each position inu800 theu800 buffer. theu800 output buffer isu800 theu800 last column ofu800 theu800 matrix; this contains theu800 whole buffer butu800 reordered sou800 that itu800 isu800 likely tou800 contain large runs ofu800 identical symbols. # move-tou800-front transform move tou800 front mtfu800 again this transform does notu800 alter theu800 size ofu800 theu800 processed block. each ofu800 theu800 symbols inu800 useu800 inu800 theu800 document isu800 placed inu800 anu800 array. when au800 symbol isu800 processed itu800 isu800 replaced byu800 itsu800 location index inu800 theu800 array andu800 that symbol isu800 shuffled tou800 theu800 front ofu800 theu800 array. theu800 effect isu800 that immediately recurring symbols areu800 replaced byu800 zero symbols long runs ofu800  anyu800  arbitrary symbol thus become runs ofu800 zero symbols while other symbols areu800 remapped according tou800 their local frequency. au800 lotu800 ofu800 natural data contains identical symbols that recur within au800 limited range text isu800 au800 good example . asu800 theu800 mtfu800 transform assigns lowu800 values tou800 symbols that reappear frequently this results inu800 au800 data stream which contains au800 lotu800 ofu800 symbols inu800 theu800 lowu800 integer range many ofu800 them being identical different recurring input symbols canu800 actually mapu800 tou800 theu800 same output symbol . such data canu800 beu800 very efficiently encoded byu800 anyu800 legacy compression method. # runu800-length encoding rleu800 long strings ofu800 repeated symbols inu800 theu800 output normally zeros byu800 this time areu800 replaced byu800 au800 combination ofu800 theu800 symbol andu800 au800 sequence ofu800 twou800 special codes runa andu800 runb which represent theu800 runu800-length asu800 au800 binary number greater than oneu800 1u800 . theu800 sequence 0u800 0u800 0u800 0u800 0u800 1u800 would beu800 represented asu800 0u800 runb runa 1u800 ; runb andu800 runa representing theu800 value 4u800 inu800 decimal. theu800 runu800-length code isu800 terminated byu800 reaching another normal symbol. this rleu800 process isu800 more flexible than theu800 rleu800 ofu800 step 1u800 asu800 itu800 isu800 able tou800 encode arbitrarily long integers inu800 practice this isu800 usually limited byu800 theu800 block size sou800 that this step does notu800 encode au800 runu800 ofu800 more than 900000 bytes . theu800 runu800-length isu800 encoded inu800 this fashion assigning place values ofu800 1u800 tou800 theu800 first bitu800 2u800 tou800 theu800 second 4u800 tou800 theu800 third etcu800. inu800 theu800 runa runb sequence multiply each place value inu800 au800 runb spot byu800 2u800 andu800 addu800 allu800 theu800 resulting place values foru800 runa andu800 runb values alike together. thus theu800 sequence runb runa results inu800 theu800 value 1u800 2u800 2u800 4u800. asu800 au800 more complicated example # runa runb runa runa runb abaab &nbsp;&nbsp;&nbsp;1u800&nbsp;&nbsp;&nbsp;&nbsp;2u800&nbsp;&nbsp;&nbsp;&nbsp;4u800&nbsp;&nbsp;&nbsp;&nbsp;8u800&nbsp;&nbsp;&nbsp;16u800 &nbsp;&nbsp;&nbsp;1u800&nbsp;&nbsp;&nbsp;&nbsp;4u800&nbsp;&nbsp;&nbsp;&nbsp;4u800&nbsp;&nbsp;&nbsp;&nbsp;8u800&nbsp;&nbsp;&nbsp;32u800 49u800 # huffman coding this process replaces fixed length symbols inu800 theu800 range 0u8e28093258 with variable length codes based onu800 theu800 frequency ofu800 useu800. more frequently used codes endu800 upu800 shorter 2u800-3u800 bits whilst rare codes canu800 beu800 allocated upu800 tou800 20u800 bits. theu800 codes areu800 selected carefully sou800 that nou800 sequence ofu800 bits canu800 beu800 confused foru800 au800 different code. theu800 endu800-ofu800-stream code isu800 particularly interesting. ifu800 there areu800  nu800  different bytes symbols used inu800 theu800 uncompressed data then theu800 huffman code will consist ofu800 twou800 rleu800 codes runa andu800 runb  nu800-1u800  symbol codes andu800 oneu800 endu800-ofu800-stream code. because ofu800 theu800 combined result ofu800 theu800 mtfu800 andu800 rleu800 encodings inu800 theu800 previous twou800 steps there isu800 never anyu800 need tou800 explicitly reference theu800 first symbol inu800 theu800 mtfu800 table thus saving oneu800 symbol foru800 theu800 endu800-ofu800-stream marker andu800 explaining whyu800 only  nu800-1u800  symbols areu800 coded inu800 theu800 huffman tree . inu800 theu800 extreme case where only oneu800 symbol isu800 used inu800 theu800 uncompressed data there will beu800 nou800 symbol codes atu800 allu800 inu800 theu800 huffman tree andu800 theu800 entire block will consist ofu800 runa andu800 runb implicitly repeating theu800 single byte andu800 anu800 endu800-ofu800-stream marker with value 2u800. # 0u800 runa 1u800 runb 2u800-257u800 byte values 0u800-255u800 258u800 endu800 ofu800 stream finish processing. could beu800 asu800 lowu800 asu800 2u800 . # multiple huffman coding huffman tables several identically-sized huffman tables canu800 beu800 used with au800 block ifu800 theu800 gain from using them isu800 greater than theu800 cost ofu800 including theu800 extra table. atu800 least twou800 2u800 andu800 upu800 tou800 sixu800 6u800 tables canu800 beu800 present with theu800 most appropriate table being reselected before every 50u800 symbols processed. this hasu800 theu800 advantage ofu800 having very responsive huffman dynamics without having tou800 continuously supply newu800 tables asu800 would beu800 required inu800 deflate . runu800-length encoding inu800 theu800 previous step isu800 designed tou800 take care ofu800 codes that have anu800 inverse probability ofu800 useu800 higher than theu800 shortest code huffman code inu800 useu800. # unary base 1u800 encoding ifu800 multiple huffman tables areu800 inu800 useu800 theu800 selection ofu800 each table numbered 0u800..5u800 isu800 done from au800 list byu800 au800 zero-terminated bitu800 runu800 between oneu800 1u800 andu800 sixu800 6u800 bits inu800 length. theu800 selection isu800 into au800 move-tou800-front transform mtfu800 list ofu800 theu800 tables. using this feature results inu800 au800 maximum expansion ofu800 around 1u800u82e015u800 butu800 generally less. this expansion isu800 likely tou800 beu800 greatly over-shadowed byu800 theu800 advantage ofu800 selecting more appropriate huffman tables andu800 theu800 common-case ofu800 continuing tou800 useu800 theu800 same huffman table isu800 represented asu800 au800 single bitu800. rather than unary encoding effectively this isu800 anu800 extreme form ofu800 au800 huffman tree where each code hasu800 half theu800 probability ofu800 theu800 previous code. # delta encoding u8ceb4 huffman code bitu800-lengths areu800 required tou800 reconstruct each ofu800 theu800 used canonical huffman tables. each bitu800-length isu800 stored asu800 anu800 encoded difference against theu800 previous code bitu800-length. au800 zero-bitu800 0u800 means that theu800 previous bitu800-length should beu800 duplicated foru800 theu800 current code whilst au800 oneu800-bitu800 1u800 means that au800 further bitu800 should beu800 read andu800 theu800 bitu800-length incremented oru800 decremented based onu800 that value. inu800 theu800 common case au800 single bitu800 isu800 used peru800 symbol peru800 table andu800 theu800 worst caseu8e28094going from length oneu800 1u800 tou800 length twenty 20u800 u8e28094would require approximately 37u800 bits. asu800 au800 result ofu800 theu800 earlier mtfu800 encoding code lengths would start atu800 2u800-3bits long very frequently used codes andu800 gradually increase meaning that theu800 delta format isu800 fairly efficientu8e28094requiring around 300u800-bits 38u800 bytes peru800 full huffman table. # sparse bitu800 array au800 bitmap isu800 used tou800 show which symbols areu800 used inside theu800 block andu800 should beu800 included inu800 theu800 huffman trees. binary data isu800 likely tou800 useu800 allu800 256u800 symbols representable byu800 au800 byte whereas textual data mayu800 only useu800 au800 small subset ofu800 available values perhaps covering theu800 ascii range between 32u800 andu800 126u800. storing 256u800 zero bits would beu800 inefficient ifu800 they were mostly unused. au800  sparse  method isu800 used theu800 256u800 symbols areu800 divided upu800 into 16u800 ranges andu800 only ifu800 symbols areu800 used within that block isu800 au800 16u800-bitu800 array included. theu800 presence ofu800 each ofu800 these 16u800 ranges isu800 indicated byu800 anu800 additional 16u800-bitu800 bitu800 array atu800 theu800 front. theu800 total bitmap uses between 32u800 andu800 272u800 bits ofu800 storage 4u8e2809334 bytes . foru800 contrast theu800 deflate algorithm would show theu800 absence ofu800 symbols byu800 encoding theu800 symbols asu800 having au800 zero bitu800-length with runu800 length encoding. file format file format file format au800 .bz2u800 stream consists ofu800 au800 4u800-byte header followed byu800 zero oru800 more compressed blocks immediately followed byu800 anu800 endu800-ofu800-stream marker containing au800 32u800-bitu800 crcu800 foru800 theu800 plaintext whole stream processed. theu800 compressed blocks areu800 bitu800-aligned andu800 nou800 padding occurs. -- paul sladen 2007-01u800-11u800 -- .magic 16u800 'bzu800' signature magic number .version 8u800 'hu800' foru800 bzip2 'hu800'uffman coding '0u800' foru800 bzip1 deprecated .hundred_k_blocksize 8u800 '1u800'..'9u800' block-size 100u800 kbu800-900u800 kbu800 uncompressed .compressed_magic 48u800 0x314159265359 bcdu800 piu800 .crcu800 32u800 checksum foru800 this block .randomised 1u800 0u800 normal 1u800 randomised deprecated .origptr 24u800 starting pointer into bwtu800 foru800 after untransform .huffman_used_map 16u800 bitmap ofu800 ranges ofu800 16u800 bytes present notu800 present .huffman_used_bitmaps 0u800..256u800 bitmap ofu800 symbols used present notu800 present multiples ofu800 16u800 .huffman_groups 3u800 2u800..6u800 number ofu800 different huffman tables inu800 useu800 .selectors_used 15u800 number ofu800 times that theu800 huffman tables areu800 swapped each 50u800 bytes .selector_list 1u800..6u800 zero-terminated bitu800 runs 0u800..62u800 ofu800 mtfu800'edu800 huffman table selectors_used .start_huffman_length 5u800 0u800..20u800 starting bitu800 length foru800 huffman deltas .delta_bit_length 1u800..40u800 0u800 next symbol; 1u800 alter length 1u800 decrement length; 0u800 increment length symbols 2u800 groups .contents 2u800..u8e2889e huffman encoded data stream until endu800 ofu800 block .eos_magic 48u800 0x177245385090 bcdu800 sqrt piu800 .crcu800 32u800 checksum foru800 whole stream .padding 0u800..7u800 align tou800 whole byte because ofu800 theu800 first-stage rleu800 compression seeu800 above theu800 maximum length ofu800 plaintext that au800 single 900u800&nbsp;kbu800 bzip2 block canu800 contain isu800 around 46u800&nbsp;mbu800 45u800 899u800 236u800&nbsp;bytes . this canu800 occur ifu800 theu800 whole plaintext consists entirely ofu800 repeated values theu800 resulting .bz2u800 file inu800 this case isu800 46u800&nbsp;bytes long . anu800 even smaller file ofu800 40u800&nbsp;bytes canu800 beu800 achieved byu800 using anu800 input containing entirely values ofu800 251u800 anu800 apparent compression ratio ofu800 1147480u82e9u800 1u800. implementations implementations implementations bzip2 julian seward 'su800 original reference implementation available under au800 bsdu800 license . 7u800-zipu800 written byu800 igor pavlov computer programmer igor pavlov inu800 cu800 theu800 7u800-zipu800 suite contains au800 bzip2 encoder decoder which isu800 freely licensed. 7u800-zipu800 comes with multi-threading support. micro-bzip2 au800 version byu800 robu800 landley designed foru800 reduced compiled code size andu800 available under theu800 gnuu800 lgpl . pbzip2 parallel posix threads pthreads -based implementation inu800 cu800 byu800 jeff gilchrist andu800 windows version . bzip2smp au800 modification tou800 libbzip2 that hasu800 symmetric multiprocessing smpu800 parallelisation hacked inu800 byu800 konstantin isakov. smpbzip2 another gou800 atu800 parallel bzip2 byu800 niels werensteijn. pyflate au800 pure- python programming language python stand-alone bzip2 andu800 deflate gzip decoder byu800 paul sladen. probably useful foru800 research andu800 prototyping made available under theu800 bsdu800 license bsdu800 gnuu800 general public license gplu800 gnuu800 lesser general public license lgpl oru800 anyu800 other debian free software guidelines dfsg -compatible license. arnaud bouchez bouchez'su800 bz2u800 delphi implementation using cu800 library oru800 optimized i386 assembler code lbzip2 parallel posix threads pthreads -based bzip2 bunzip2 bzip2 compressor decompressor filter foru800 sequential access input output byu800 lu8c3a1szlu8c3b3 u8c3a9rsek. mpibzip2 anu800 message passing interface mpiu800 -enabled implementation that compresses decompresses inu800 parallel byu800 jeff gilchrist available under au800 bsdu800-style license. apache commons compress apache commons compress project contains java implementations ofu800 bzip2 compressor andu800 decompressor. jbzip2 au800 java implementation ofu800 bzip2 made available under theu800 mitu800 license dotnetzip includes au800 cu800# implementation ofu800 bzip2 derived from theu800 java implementation inu800 apache commons compress. includes au800 multi-threaded .netu800 bzip2 encoder decoder library andu800 au800 bzip2 command-line tool inu800 managed code. seeu800 also seeu800 also seeu800 also portal free software comparison ofu800 archive formats list ofu800 archive formats list ofu800 file archivers comparison ofu800 file archivers list ofu800 unix programs rzip references references references reflist external links external links external links official website bzipu82eorgu800 theu800 bzip2 command - byu800 theu800 linux information project linfo bzip2 foru800 windows graphical bzip2 foru800 windows wbzip2 macbzip2 foru800 classic macu800 osu800 ; under macu800 osu800 xu800 theu800 standard bzip2 isu800 available atu800 theu800 command line feature comparison andu800 benchmarks foru800 different kinds ofu800 parallel bzip2 implementations available 4u800 parallel bzip2 implementations atu800 theu800 data compression news blog theu800 original bzip compressor - mayu800 beu800 restricted byu800 patents archive formats compression software implementations floss category lossless compression algorithms category free data compression software category unix archivers andu800 compression-related utilities category archive formats category cross-platform software category 1996 software 